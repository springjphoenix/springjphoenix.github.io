{"version":3,"sources":["webpack:///path---page-6-30d46f4b591a09091403.js","webpack:///./.cache/json/page-6.json"],"names":["webpackJsonp","635","module","exports","data","site","siteMetadata","title","allMarkdownRemark","edges","node","html","timeToRead","excerpt","fields","slug","frontmatter","date","category","tags","pathContext","current","skip","total"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,mBAA0BC,mBAAsBC,QAAUC,MAAQC,KAAA,k7bAA4yUC,WAAA,EAAAC,QAAA,wIAAAC,QAA02IC,KAAA,8BAAoCC,aAAgBT,MAAA,gBAAAU,KAAA,aAAAC,SAAA,OAAAC,MAAA,2BAAiGT,MAAQC,KAAA;AAA8pwFC,WAAA,EAAAC,QAAA,sIAAAC,QAA2gFC,KAAA,8CAAoDC,aAAgBT,MAAA,qCAAAU,KAAA,aAAAC,SAAA,OAAAC,MAAA,uCAAkIT,MAAQC,KAAA,gvqBAA+pfC,WAAA,EAAAC,QAAA,sIAAAC,QAAq/MC,KAAA,iCAAuCC,aAAgBT,MAAA,mBAAAU,KAAA,aAAAC,SAAA,OAAAC,MAAA,yCAAiHC,aAAgBC,QAAA,EAAAC,KAAA,GAAAC,MAAA","file":"path---page-6-30d46f4b591a09091403.js","sourcesContent":["webpackJsonp([195745506856481],{\n\n/***/ 635:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Magicly's Blog\"}},\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"html\":\"<p>经常遇到一个问题，需要在内存里缓存一批数据来提高效率（避免每次都读取DB）。那问题来了，这些对象到底会占用多大内存呢，这直接决定了可以缓存多少条记录，以及上线之后是否会内存不够等问题。</p>\\n<p>来看几种解决方法。</p>\\n<!-- more -->\\n<h1 id=\\\"测试\\\"><a href=\\\"#%E6%B5%8B%E8%AF%95\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>测试</h1>\\n<p>实践是检验真理的唯一标准！比如你要想cache10w条记录，那你就把10w条记录加载到内存，然后看看到底用了多少内存。至于怎么看内存花了多少，你可以</p>\\n<ol>\\n<li>任务管理器</li>\\n<li>top</li>\\n<li>Java Runtime类</li>\\n<li>blabla。。。。</li>\\n</ol>\\n<p>我们来看看直接从Java程序里能获取到的Runtime。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">import</span> java<span class=\\\"token punctuation\\\">.</span>util<span class=\\\"token punctuation\\\">.</span>*<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">/**\\n * Created by magicalli on 2015/2/3.\\n */</span>\\n<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">TestMemory</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">A</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">int</span> a<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">main</span><span class=\\\"token punctuation\\\">(</span>String<span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span> args<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"--- Memory Usage ---:\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        Runtime rt <span class=\\\"token operator\\\">=</span> Runtime<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getRuntime</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token comment\\\">//打印总内存大小 //打印空闲内存大小 //打印已用内存大小 单位(字节)</span>\\n        <span class=\\\"token keyword\\\">long</span> usedMemory <span class=\\\"token operator\\\">=</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">totalMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">-</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">freeMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Total Memory= \\\"</span> <span class=\\\"token operator\\\">+</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">totalMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\" Free Memory = \\\"</span> <span class=\\\"token operator\\\">+</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">freeMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\" Used　Memory=\\\"</span> <span class=\\\"token operator\\\">+</span> usedMemory<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n        <span class=\\\"token comment\\\">// 把你要测试的占用内存的代码放在这里------start--------------</span>\\n        <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">int</span> N <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">100000</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">int</span><span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span> arr <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">int</span><span class=\\\"token punctuation\\\">[</span>N<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n        Integer<span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span> arr2 <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Integer</span><span class=\\\"token punctuation\\\">[</span>N<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n        A<span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span> arrA <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">A</span><span class=\\\"token punctuation\\\">[</span>N<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> i <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> i <span class=\\\"token operator\\\">&lt;</span> N<span class=\\\"token punctuation\\\">;</span> i<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            arr<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">=</span> i<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">//            arr2[i] = i;</span>\\n<span class=\\\"token comment\\\">//            arrA[i] = new A();</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token comment\\\">//        List&lt;Integer> list = new ArrayList&lt;Integer>();</span>\\n        Map<span class=\\\"token generics function\\\"><span class=\\\"token punctuation\\\">&lt;</span>Integer<span class=\\\"token punctuation\\\">,</span> String<span class=\\\"token punctuation\\\">></span></span> map <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">HashMap</span><span class=\\\"token generics function\\\"><span class=\\\"token punctuation\\\">&lt;</span>Integer<span class=\\\"token punctuation\\\">,</span> String<span class=\\\"token punctuation\\\">></span></span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">//        for (int i = 0; i &lt; N; i++) {</span>\\n<span class=\\\"token comment\\\">//            list.add(i);</span>\\n<span class=\\\"token comment\\\">//            map.put(i, UUID.randomUUID().toString());</span>\\n<span class=\\\"token comment\\\">//        }</span>\\n<span class=\\\"token comment\\\">//        System.out.println(map.size());</span>\\n        <span class=\\\"token comment\\\">// 把你要测试的占用内存的代码放在这里------end--------------</span>\\n\\n        <span class=\\\"token keyword\\\">long</span> usedMemory2 <span class=\\\"token operator\\\">=</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">totalMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">-</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">freeMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Total Memory= \\\"</span> <span class=\\\"token operator\\\">+</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">totalMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\" Free Memory = \\\"</span> <span class=\\\"token operator\\\">+</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">freeMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\" Used　Memory=\\\"</span> <span class=\\\"token operator\\\">+</span> usedMemory2<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">long</span> objMemory <span class=\\\"token operator\\\">=</span> usedMemory2 <span class=\\\"token operator\\\">-</span> usedMemory<span class=\\\"token punctuation\\\">;</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"object use memory: \\\"</span> <span class=\\\"token operator\\\">+</span> objMemory <span class=\\\"token operator\\\">/</span> <span class=\\\"token number\\\">1024</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\"k\\\"</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\" each is: \\\"</span> <span class=\\\"token operator\\\">+</span> objMemory <span class=\\\"token operator\\\">/</span> N<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>上面方法的最大好处就是可以直接获得实际占用内存大小，是比较简单有效的方法。不好的地方就是如果数据量比较小，可能偏差比较大，而且你也不能解释为什么Integer[]比int[]占用内存大很多，关键是专家说：这种内存占用应该是心里算出来的，你还要去run一下程序，明显就low了，还想晋级？再练练吧！所以我们来看看怎么掐指一算！</p>\\n<h1 id=\\\"计算\\\"><a href=\\\"#%E8%AE%A1%E7%AE%97\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>计算</h1>\\n<p>这个需要了解JVM里的内存分布，知道每个对象都有object header，blabal。这里推荐一篇好文<a href=\\\"http://www.cnblogs.com/magialmoon/p/3757767.html\\\">一个Java对象到底占用多大内存？</a>，我就不重复了。</p>\\n<p>还看到另一种计算方式，用的Unsafe，不过感觉没有前面用Instrumentation的好。参考这里<a href=\\\"http://blog.csdn.net/bobpauline/article/details/20699233\\\">Java计算一个对象占用内存的大小</a></p>\\n<h1 id=\\\"线上查看\\\"><a href=\\\"#%E7%BA%BF%E4%B8%8A%E6%9F%A5%E7%9C%8B\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>线上查看</h1>\\n<p>如果是要查看线上程序哪个对象占用了大量内存（比如分析内存泄露），那么可以使用jmap。</p>\\n<h1 id=\\\"相关知识\\\"><a href=\\\"#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>相关知识</h1>\\n<p>你可能需要了解jps，jinfo，打包jar，manifest，查看jvm运行参数等。</p>\\n<h1 id=\\\"refers\\\"><a href=\\\"#refers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Refers</h1>\\n<ol>\\n<li><a href=\\\"http://www.importnew.com/14948.html\\\">http://www.importnew.com/14948.html</a></li>\\n<li><a href=\\\"http://www.cnblogs.com/magialmoon/p/3757767.html\\\">http://www.cnblogs.com/magialmoon/p/3757767.html</a></li>\\n<li><a href=\\\"http://www.oschina.net/question/1_4486\\\">http://www.oschina.net/question/1_4486</a></li>\\n<li><a href=\\\"http://blog.csdn.net/bobpauline/article/details/20699233\\\">http://blog.csdn.net/bobpauline/article/details/20699233</a></li>\\n<li><a href=\\\"http://happyqing.iteye.com/blog/2013639\\\">http://happyqing.iteye.com/blog/2013639</a></li>\\n<li><a href=\\\"http://sunqi.iteye.com/blog/1917802\\\">http://sunqi.iteye.com/blog/1917802</a></li>\\n<li><a href=\\\"http://www.blogjava.net/stone2083/archive/2013/06/08/400410.html\\\">http://www.blogjava.net/stone2083/archive/2013/06/08/400410.html</a></li>\\n<li><a href=\\\"http://yueyemaitian.iteye.com/blog/2033046\\\">http://yueyemaitian.iteye.com/blog/2033046</a></li>\\n<li><a href=\\\"http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html\\\">http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html</a></li>\\n<li><a href=\\\"http://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/\\\">http://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/</a></li>\\n</ol>\\n<blockquote>\\n<p>Written with <a href=\\\"https://stackedit.io/\\\">StackEdit</a>.</p>\\n</blockquote>\",\"timeToRead\":2,\"excerpt\":\"经常遇到一个问题，需要在内存里缓存一批数据来提高效率（避免每次都读取DB）。那问题来了，这些对象到底会占用多大内存呢，这直接决定了可以缓存多少条记录，以及上线之后是否会内存不够等问题。 来看几种解决方法。 测试 实践是检验真理的唯一标准！比如你要想cache10w…\",\"fields\":{\"slug\":\"/how-big-is-a-java-object/\"},\"frontmatter\":{\"title\":\"一个Java对象到底有多大\",\"date\":\"2015-06-13\",\"category\":\"Java\",\"tags\":[\"Java\",\"JVM\",\"Java反射\"]}}},{\"node\":{\"html\":\"<p>java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了</p>\\n<ol>\\n<li>atomic包里Integer/Long对应的原子类，主要基于CAS；</li>\\n<li>一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；</li>\\n<li>关于线程执行的Executors类等；</li>\\n<li>一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。</li>\\n</ol>\\n<p>今天我们主要介绍AbstractQueuedSynchronizer这个可以说是最核心的类，没有之一。整个concurrent包里，基本都直接或间接地用到了这个类。Doug Lea的这篇<a href=\\\"http://gee.cs.oswego.edu/dl/papers/aqs.pdf\\\">论文</a>里面讲AQS的实现。</p>\\n<!-- more -->\\n<h1 id=\\\"aqs\\\"><a href=\\\"#aqs\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>AQS</h1>\\n<p>首先，我们来想象一下，一间屋里有一个大家都想要得到的会让你很爽的东西（something which makes you so happy, e.g. W.C）。当有人进去把门关起来在独占享用的时候，其他人就只能在外面排队等待，既然在等待，你就不能老是去敲门说哎，好了没有啊。老是这样的话里面的人就很不爽了，而且你可以利用这点等待时间干点别的，比如看看小说视频背背单词或者就干脆椅子上睡觉，当前面独占的人爽完之后，就会出来说，啊，好爽，到你们了。然后大家可能按照排队顺序获取或者大家疯抢这个状态，有可能一个人自己进去独占，有可能几个人说，哎没关系，我们可以一起来。然后他们进去爽，爽完之后再出来通知下一个。</p>\\n<p>我们来把上面这段话翻译成AQS里面的术语。有一个状态state，会有多个Thread尝试获取，当一个Thread独占（EXCLUSIVE，比如Lock）之后，其他后面到来的Thread就会被放到一个Queue的队尾（tail），然后睡眠（park），一直等到前面的Thread唤醒（unpark）它，当然这里有可能被假唤醒（就好比你定了闹钟8点起床，结果7点就自然醒或者被外面车吵醒），所以这个Thread会判断一下是不是到自己了，没有的话就继续park（在一个死循环里）；当拥有state的Thread释放（release）之后，它会唤醒Queue中的下一个Thread（unparkSuccessor）。然后下一个Thread获取（acquire）到state，完成自己的任务，然后继续unparkSuccessor。前面主要说的是EXCLUSIVE模式，AQS还支持共享（SHARED）模式，区别在于尝试获取（tryAcquireShared）的时候即使之前已经有Thread获取了state，但是可能仍然能获取（比如ReadLock）。同样释放（doReleaseShared）的时候除了通知Queue里面第一个（head），还会继续通知后续的节点（Node），只要它们是SHARED。</p>\\n<p>AQS就是实现了：</p>\\n<ol>\\n<li>自动管理这个同步状态state（int类型），更新的时候需要用CAS保证原子性</li>\\n<li>阻塞和唤醒线程park/unpark</li>\\n<li>队列管理，一个双向链表实现queue</li>\\n</ol>\\n<p>AQS是一个abstract class，可以通过继承AQS，定义state的含义，以及tryAcquire，tryRelease，以及对应的share模式下tryAcquireShared，tryReleaseShared这几个方法，定义出自己想要的同步子（Synchronizers）。一般而言，是定义一个内部类Sync extends AQS，实现前面说的几个方法，然后再包一层，暴露出相应的方法。这样做的好处是你可以在包装器类里面取更直观的名字，如ReentrantLock里的lock，unlock和CountDownLatch里的countDown，await，而不是太通用的acquire和release等。而且AQS里面一些方法是为了监控和调试使用，直接暴露出来也不好。</p>\\n<p>下面我们来看J.U.C里面两个常用的Synchronizers。</p>\\n<h1 id=\\\"reentrantlock\\\"><a href=\\\"#reentrantlock\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>ReentrantLock</h1>\\n<h2 id=\\\"使用\\\"><a href=\\\"#%E4%BD%BF%E7%94%A8\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>使用</h2>\\n<p>ReentrantLock的语义跟synchronized关键字基本一样，而且我之前看<a href=\\\"http://book.douban.com/subject/6522893/\\\">《深入理解Java虚拟机》</a>里面的评测说JDK6之后，两者的效率基本一致了（JDK5之前ReentrantLock要比synchronized快很多）。Javadoc里面说基本用法如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">X</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">final</span> ReentrantLock lock <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">ReentrantLock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n  <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">m</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    lock<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>  <span class=\\\"token comment\\\">// block until condition holds</span>\\n    <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token comment\\\">// ... method body</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">finally</span> <span class=\\\"token punctuation\\\">{</span>\\n      lock<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">unlock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<h2 id=\\\"源码\\\"><a href=\\\"#%E6%BA%90%E7%A0%81\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>源码</h2>\\n<p>ReentrantLock用state表示是否被锁，0表示没有线程获取到锁，>=1表示某个线程获取了N次锁（因为是重入的，只要保证lock和unlock成对出现就没有问题）。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token comment\\\">/** Synchronizer providing all implementation mechanics */</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">final</span> Sync sync<span class=\\\"token punctuation\\\">;</span>\\n\\n    <span class=\\\"token keyword\\\">abstract</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Sync</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">AbstractQueuedSynchronizer</span> <span class=\\\"token punctuation\\\">{</span></code></pre>\\n      </div>\\n<p>定义了一个内部类，基本任务都代理给sync完成。而Sync又是一个abstract class，这里主要是因为实现了两种抢占锁的机制，公平锁和非公平锁。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">FairSync</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">Sync</span>\\n\\t\\n\\t<span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">NonfairSync</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">Sync</span></code></pre>\\n      </div>\\n<p>所谓公平不公平简单来说就是本文开头说的，当资源释放的时候，大家是按照排队顺序先到先得，还是有人插队大家疯抢。</p>\\n<p>提供了两个构造函数：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token function\\\">ReentrantLock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        sync <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">NonfairSync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//默认非公平锁，AQS论文说非公平锁效率高些，理由其实很简单，公平锁通知队列第一个节点，要把它唤醒，而唤醒是需要时间的，在锁释放到第一个节点被唤醒这段时间其实锁是可以用但是没有被用的（available but not used）；而非公平锁，释放了之后立马就可以被别人用，所以提高了效率，但是有可能导致饥饿锁，这个就要具体看业务需求了。</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token function\\\">ReentrantLock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">boolean</span> fair<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        sync <span class=\\\"token operator\\\">=</span> fair <span class=\\\"token operator\\\">?</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">FairSync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">:</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">NonfairSync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//指定公平与否</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>加锁的实现</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        sync<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>简单代理给了sync，在FairSync里为</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n\\t\\t<span class=\\\"token function\\\">acquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\t<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>acquire的实现在AQS里面：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">acquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token operator\\\">!</span><span class=\\\"token function\\\">tryAcquire</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&amp;&amp;</span>\\n            <span class=\\\"token function\\\">acquireQueued</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">addWaiter</span><span class=\\\"token punctuation\\\">(</span>Node<span class=\\\"token punctuation\\\">.</span>EXCLUSIVE<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span> arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token function\\\">selfInterrupt</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>tryAcquire是要在子类里自己实现的，在FairSync如下;</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t\\t <span class=\\\"token keyword\\\">protected</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">tryAcquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> acquires<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">final</span> Thread current <span class=\\\"token operator\\\">=</span> Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">int</span> c <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>c <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//0表示锁没有被线程用，1表示已经有线程占用</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token operator\\\">!</span><span class=\\\"token function\\\">hasQueuedPredecessors</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&amp;&amp;</span> <span class=\\\"token comment\\\">//判断自己是否是第一个节点，实现公平</span>\\n                    <span class=\\\"token function\\\">compareAndSetState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> acquires<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//CAS更新状态</span>\\n                    <span class=\\\"token function\\\">setExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span>current<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//设置当前线程拥有状态</span>\\n                    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>current <span class=\\\"token operator\\\">==</span> <span class=\\\"token function\\\">getExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//1表示已经有线程占用，再判断一下是否被当前线程占用，来实现重入（Reentrant）特性</span>\\n                <span class=\\\"token keyword\\\">int</span> nextc <span class=\\\"token operator\\\">=</span> c <span class=\\\"token operator\\\">+</span> acquires<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>nextc <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Error</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Maximum lock count exceeded\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>nextc<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//更新状态</span>\\n                <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>如果获取失败，addWaiter(Node.EXCLUSIVE)将当前线程加入队尾</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">private</span> Node <span class=\\\"token function\\\">addWaiter</span><span class=\\\"token punctuation\\\">(</span>Node mode<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        Node node <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Node</span><span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span> mode<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//用当前线程构造Node，独占模式</span>\\n        <span class=\\\"token comment\\\">// Try the fast path of enq; backup to full enq on failure</span>\\n        Node pred <span class=\\\"token operator\\\">=</span> tail<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>pred <span class=\\\"token operator\\\">!=</span> null<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            node<span class=\\\"token punctuation\\\">.</span>prev <span class=\\\"token operator\\\">=</span> pred<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetTail</span><span class=\\\"token punctuation\\\">(</span>pred<span class=\\\"token punctuation\\\">,</span> node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//快速判断，CAS更新tail节点</span>\\n                pred<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">return</span> node<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token function\\\">enq</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//如果失败，进入enq方法</span>\\n        <span class=\\\"token keyword\\\">return</span> node<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n    \\n\\t <span class=\\\"token keyword\\\">private</span> Node <span class=\\\"token function\\\">enq</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">final</span> Node node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            Node t <span class=\\\"token operator\\\">=</span> tail<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>t <span class=\\\"token operator\\\">==</span> null<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">// Must initialize</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetHead</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Node</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//如果还没有head，CAS初始化一个head</span>\\n                    tail <span class=\\\"token operator\\\">=</span> head<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//这段代码跟addWaiter里一样，CAS更新tail节点</span>\\n                node<span class=\\\"token punctuation\\\">.</span>prev <span class=\\\"token operator\\\">=</span> t<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetTail</span><span class=\\\"token punctuation\\\">(</span>t<span class=\\\"token punctuation\\\">,</span> node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                    t<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token keyword\\\">return</span> t<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>现在我们已经将获取不到锁的线程加入队尾了，现在要将它挂起acquireQueued(addWaiter(Node.EXCLUSIVE), arg))：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">acquireQueued</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">final</span> Node node<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">boolean</span> failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">boolean</span> interrupted <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//在一个死循环中，避免假唤醒</span>\\n                <span class=\\\"token keyword\\\">final</span> Node p <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">predecessor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//获取当前节点的前一个节点，如果是head说明自己是第一个可以获取资源的线程，实现公平</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>p <span class=\\\"token operator\\\">==</span> head <span class=\\\"token operator\\\">&amp;&amp;</span> <span class=\\\"token function\\\">tryAcquire</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//是第一个可以获取资源的线程并且尝试获取成功</span>\\n                    <span class=\\\"token function\\\">setHead</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                    p<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> null<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// help GC</span>\\n                    failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token keyword\\\">return</span> interrupted<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">shouldParkAfterFailedAcquire</span><span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">,</span> node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&amp;&amp;</span>\\n                    <span class=\\\"token function\\\">parkAndCheckInterrupt</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//没有获取到资源，睡眠park去</span>\\n                    interrupted <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">finally</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>failed<span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token function\\\">cancelAcquire</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">parkAndCheckInterrupt</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        LockSupport<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">park</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">return</span> Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">interrupted</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>上面完成了获取锁的过程，简单来说就是尝试获取，失败就加入队尾，挂起，等待被唤醒。</p>\\n<p>下面来看看释放锁</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">unlock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        sync<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">release</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//代理给sync，调用AQS的release</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token comment\\\">//下面代码在AQS中</span>\\n\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">release</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">tryRelease</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//尝试释放资源，需要在子类里实现</span>\\n            Node h <span class=\\\"token operator\\\">=</span> head<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>h <span class=\\\"token operator\\\">!=</span> null <span class=\\\"token operator\\\">&amp;&amp;</span> h<span class=\\\"token punctuation\\\">.</span>waitStatus <span class=\\\"token operator\\\">!=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token function\\\">unparkSuccessor</span><span class=\\\"token punctuation\\\">(</span>h<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//通知下一个节点</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">unparkSuccessor</span><span class=\\\"token punctuation\\\">(</span>Node node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token comment\\\">/*\\n         * If status is negative (i.e., possibly needing signal) try\\n         * to clear in anticipation of signalling.  It is OK if this\\n         * fails or if status is changed by waiting thread.\\n         */</span>\\n        <span class=\\\"token keyword\\\">int</span> ws <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span>waitStatus<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>ws <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token function\\\">compareAndSetWaitStatus</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">,</span> ws<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n        <span class=\\\"token comment\\\">/*\\n         * Thread to unpark is held in successor, which is normally\\n         * just the next node.  But if cancelled or apparently null,\\n         * traverse backwards from tail to find the actual\\n         * non-cancelled successor.\\n         */</span>\\n         <span class=\\\"token comment\\\">// 主要在这里找到下一个需要通知的节点，如果node.next就是需要通知的节点，则直接通知；否则，可能node.next == null（原因是双向链表设置b.pre = a和a.next = b的时候不能保证原子性，只能保证b.pre = a成功，这时候另一条线程可能看到a.next == null）或者s.waitStatus > 0（原因是线程等不及被取消了static final int CANCELLED = 1;），这个时候就要从队尾tail开始找，找到离队头head最近的一个需要通知的节点Node。</span>\\n        Node s <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span>next<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>s <span class=\\\"token operator\\\">==</span> null <span class=\\\"token operator\\\">||</span> s<span class=\\\"token punctuation\\\">.</span>waitStatus <span class=\\\"token operator\\\">></span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            s <span class=\\\"token operator\\\">=</span> null<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span>Node t <span class=\\\"token operator\\\">=</span> tail<span class=\\\"token punctuation\\\">;</span> t <span class=\\\"token operator\\\">!=</span> null <span class=\\\"token operator\\\">&amp;&amp;</span> t <span class=\\\"token operator\\\">!=</span> node<span class=\\\"token punctuation\\\">;</span> t <span class=\\\"token operator\\\">=</span> t<span class=\\\"token punctuation\\\">.</span>prev<span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>t<span class=\\\"token punctuation\\\">.</span>waitStatus <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n                    s <span class=\\\"token operator\\\">=</span> t<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>s <span class=\\\"token operator\\\">!=</span> null<span class=\\\"token punctuation\\\">)</span>\\n            LockSupport<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">unpark</span><span class=\\\"token punctuation\\\">(</span>s<span class=\\\"token punctuation\\\">.</span>thread<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//唤醒线程</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>看看需要在子类里实现的tryRelease：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t\\t<span class=\\\"token keyword\\\">protected</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">tryRelease</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> releases<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">int</span> c <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">-</span> releases<span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//释放锁，state减去相应的值</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">!=</span> <span class=\\\"token function\\\">getExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">IllegalMonitorStateException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//避免A线程锁了之后，B线程故意捣乱释放锁</span>\\n            <span class=\\\"token keyword\\\">boolean</span> free <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>c <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//当前线程已经完全释放了锁</span>\\n                free <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token function\\\">setExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span>null<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//释放锁的拥有者</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>c<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//设置状态，这个方面没有同步，没有CAS，有同学问过岂不是有线程并发问题？其实到这里，只有一个线程会调用这个方法，所以不会有并发错误，仔细想想，是吧？是吧？</span>\\n            <span class=\\\"token keyword\\\">return</span> free<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>到这里，基本都已经完成，对了，还没有说非公平锁NonfairSync是怎么抢占锁的。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t\\t<span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//先抢一把（插队），万一成功了就不排队，不公平性就体现在这里！</span>\\n                <span class=\\\"token function\\\">setExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">else</span>\\n                <span class=\\\"token function\\\">acquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>跟FairSync.lock()对比，可以看出，只是在acquire(1)之前，先抢一把，抢不到才乖乖的去排队。</p>\\n<p>我们再看看NonfairSync.tryAcquire()怎么实现的</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t\\t<span class=\\\"token keyword\\\">protected</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">tryAcquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> acquires<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">nonfairTryAcquire</span><span class=\\\"token punctuation\\\">(</span>acquires<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//调用父类方法nonfairTryAcquire</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t\\t<span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">nonfairTryAcquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> acquires<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">final</span> Thread current <span class=\\\"token operator\\\">=</span> Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">int</span> c <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>c <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> acquires<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//跟FairSync.tryAcquire只有这里一行有差异，即少了!hasQueuedPredecessors()，也就是说不判断前面有没有人，任何时候只要它醒来，都会去抢，所以不公平！============刚又看了一遍，发现其实final boolean acquireQueued(final Node node, int arg)方法里已经有node.predecessor() == head的判断，感觉这个不公平的tryAcquire貌似没有意义，各位看官怎么看呢，请留言哈，谢谢~</span>\\n                    <span class=\\\"token function\\\">setExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span>current<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>current <span class=\\\"token operator\\\">==</span> <span class=\\\"token function\\\">getExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">int</span> nextc <span class=\\\"token operator\\\">=</span> c <span class=\\\"token operator\\\">+</span> acquires<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>nextc <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// overflow</span>\\n                    <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Error</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Maximum lock count exceeded\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>nextc<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<h1 id=\\\"countdownlatch\\\"><a href=\\\"#countdownlatch\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>CountDownLatch</h1>\\n<p>我们之前说了，AQS支持独占EXCLUSIVE和共享SHARED两种模式，而刚刚的ReentrantLock的就是独占模式，我们来看看一个使用共享模式的类。</p>\\n<h2 id=\\\"使用-1\\\"><a href=\\\"#%E4%BD%BF%E7%94%A8-1\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>使用</h2>\\n<p>CountDownLatch就好比一道门，它可以用来等所有资源都到齐了，才开门，让这些线程同时通过。比如如下是CountDownLatch一个通用用法：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">package</span> concurrentStudy<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">import</span> java<span class=\\\"token punctuation\\\">.</span>util<span class=\\\"token punctuation\\\">.</span>concurrent<span class=\\\"token punctuation\\\">.</span>CountDownLatch<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">/**\\n * Created by magicalli on 2014/12/13.\\n */</span>\\n<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">IndexPlusPlusTest01</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">int</span> NThreads <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">// 线程数</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">int</span> M <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">100000</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//循环次数，太小的话（比如10）可能看不出来效果</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">volatile</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">int</span> n <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//加volatile的目的是为了证明volatile没有“原子性”！</span>\\n\\n    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">main</span><span class=\\\"token punctuation\\\">(</span>String<span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span> args<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">final</span> CountDownLatch startGate <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">CountDownLatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">final</span> CountDownLatch endGate <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">CountDownLatch</span><span class=\\\"token punctuation\\\">(</span>NThreads<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n        <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> i <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> i <span class=\\\"token operator\\\">&lt;</span> NThreads<span class=\\\"token punctuation\\\">;</span> i<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Thread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Runnable</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token annotation punctuation\\\">@Override</span>\\n                <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                    <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n                        startGate<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">await</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//所有线程start之后等待“门“打开，保证同时真正开始运行</span>\\n                    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token class-name\\\">InterruptedException</span> e<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                        e<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">printStackTrace</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token punctuation\\\">}</span>\\n\\n                    <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> j <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> j <span class=\\\"token operator\\\">&lt;</span> M<span class=\\\"token punctuation\\\">;</span> j<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                        n <span class=\\\"token operator\\\">+=</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token punctuation\\\">}</span>\\n\\n                    endGate<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">countDown</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">start</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n\\n        startGate<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">countDown</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//打开“门”，让所有线程同时run起来</span>\\n        <span class=\\\"token keyword\\\">long</span> t1 <span class=\\\"token operator\\\">=</span> System<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentTimeMillis</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        endGate<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">await</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//等所有线程都结束之后才打印n，否则总是会打出错误的n；我见过这里用Thread.sleep()，但是问题在于，你怎么知道该等多久才能保证所有线程结束以及刚好结束呢？！</span>\\n        <span class=\\\"token keyword\\\">long</span> t2 <span class=\\\"token operator\\\">=</span> System<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentTimeMillis</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"cost time: \\\"</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token punctuation\\\">(</span>t2 <span class=\\\"token operator\\\">-</span> t1<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"n: \\\"</span> <span class=\\\"token operator\\\">+</span> n<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>对了，上面代码是拿来验证volatile不具备原子性的，是错误的代码哦。如果想并发安全，大家可以想想可以用哪些方式实现。</p>\\n<h2 id=\\\"源码-1\\\"><a href=\\\"#%E6%BA%90%E7%A0%81-1\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>源码</h2>\\n<p>CountDownLatch同样也是定义了一个继承自AQS的内部类Sync：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Sync</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">AbstractQueuedSynchronizer</span></code></pre>\\n      </div>\\n<p>构造函数如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token function\\\">CountDownLatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> count<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>count <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">IllegalArgumentException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"count &lt; 0\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>sync <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Sync</span><span class=\\\"token punctuation\\\">(</span>count<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>count表示有多少个任务还在运行，每个Thread完成了任务或者准备好开始之前，就会调用countDown方法将count-1，当count==0时候，await就不再阻塞，所有在上面阻塞的Thread都可以顺利通过。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">await</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        sync<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">acquireSharedInterruptibly</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>直接调用AQS的acquireSharedInterruptibly方法，从方法名可以看出，支持中断响应</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">acquireSharedInterruptibly</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">interrupted</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">InterruptedException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//响应中断</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">tryAcquireShared</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token function\\\">doAcquireSharedInterruptibly</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>tryAcquireShared在子类中实现：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">        <span class=\\\"token keyword\\\">protected</span> <span class=\\\"token keyword\\\">int</span> <span class=\\\"token function\\\">tryAcquireShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> acquires<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">?</span> <span class=\\\"token number\\\">1</span> <span class=\\\"token operator\\\">:</span> <span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//如果state为0，说明所有Thread完成任务，可以不阻塞了</span>\\n        <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>如果没有获取到，将Thread加入队尾，挂起。下面这个方法跟独占模式下acquireQueued(addWaiter(Node.EXCLUSIVE), arg))这个方法代码是基本一致的。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">doAcquireSharedInterruptibly</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span>\\n        <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">final</span> Node node <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">addWaiter</span><span class=\\\"token punctuation\\\">(</span>Node<span class=\\\"token punctuation\\\">.</span>SHARED<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//共享模式</span>\\n        <span class=\\\"token keyword\\\">boolean</span> failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">final</span> Node p <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">predecessor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>p <span class=\\\"token operator\\\">==</span> head<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                    <span class=\\\"token keyword\\\">int</span> r <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">tryAcquireShared</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>r <span class=\\\"token operator\\\">>=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                        <span class=\\\"token function\\\">setHeadAndPropagate</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">,</span> r<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//跟EXCLUSIVE的一大区别</span>\\n                        p<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> null<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// help GC</span>\\n                        failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n                        <span class=\\\"token keyword\\\">return</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token punctuation\\\">}</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">shouldParkAfterFailedAcquire</span><span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">,</span> node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&amp;&amp;</span>\\n                    <span class=\\\"token function\\\">parkAndCheckInterrupt</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">InterruptedException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//响应中断，这里直接抛异常</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">finally</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>failed<span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token function\\\">cancelAcquire</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">setHeadAndPropagate</span><span class=\\\"token punctuation\\\">(</span>Node node<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> propagate<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        Node h <span class=\\\"token operator\\\">=</span> head<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// Record old head for check below</span>\\n        <span class=\\\"token function\\\">setHead</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token comment\\\">/*\\n         * Try to signal next queued node if:\\n         *   Propagation was indicated by caller,\\n         *     or was recorded (as h.waitStatus either before\\n         *     or after setHead) by a previous operation\\n         *     (note: this uses sign-check of waitStatus because\\n         *      PROPAGATE status may transition to SIGNAL.)\\n         * and\\n         *   The next node is waiting in shared mode,\\n         *     or we don't know, because it appears null\\n         *\\n         * The conservatism in both of these checks may cause\\n         * unnecessary wake-ups, but only when there are multiple\\n         * racing acquires/releases, so most need signals now or soon\\n         * anyway.\\n         */</span>\\n         <span class=\\\"token comment\\\">// 如果当前节点是愿意共享，并且下一个节点也是愿意共享的，那么就进入doReleaseShared，唤醒下一个节点，下面会详解</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>propagate <span class=\\\"token operator\\\">></span> <span class=\\\"token number\\\">0</span> <span class=\\\"token operator\\\">||</span> h <span class=\\\"token operator\\\">==</span> null <span class=\\\"token operator\\\">||</span> h<span class=\\\"token punctuation\\\">.</span>waitStatus <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span> <span class=\\\"token operator\\\">||</span>\\n            <span class=\\\"token punctuation\\\">(</span>h <span class=\\\"token operator\\\">=</span> head<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">==</span> null <span class=\\\"token operator\\\">||</span> h<span class=\\\"token punctuation\\\">.</span>waitStatus <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            Node s <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span>next<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>s <span class=\\\"token operator\\\">==</span> null <span class=\\\"token operator\\\">||</span> s<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">isShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token function\\\">doReleaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>前面完成了等待CountDownLatch的count变成0的过程，下面看看countDown</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">countDown</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        sync<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">releaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//调用AQS的</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token comment\\\">// AQS中</span>\\n\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">releaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">tryReleaseShared</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//尝试释放，需要在子类中实现</span>\\n            <span class=\\\"token function\\\">doReleaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//真正释放</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t\\t<span class=\\\"token comment\\\">// Sync子类中实现</span>\\n\\t    <span class=\\\"token keyword\\\">protected</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">tryReleaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> releases<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token comment\\\">// Decrement count; signal when transition to zero</span>\\n            <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">int</span> c <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>c <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">int</span> nextc <span class=\\\"token operator\\\">=</span> c<span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetState</span><span class=\\\"token punctuation\\\">(</span>c<span class=\\\"token punctuation\\\">,</span> nextc<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">// 在死循环中CAS将count-1</span>\\n                    <span class=\\\"token keyword\\\">return</span> nextc <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        \\n    <span class=\\\"token comment\\\">// AQS中</span>\\n\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">doReleaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token comment\\\">/*\\n         * Ensure that a release propagates, even if there are other\\n         * in-progress acquires/releases.  This proceeds in the usual\\n         * way of trying to unparkSuccessor of head if it needs\\n         * signal. But if it does not, status is set to PROPAGATE to\\n         * ensure that upon release, propagation continues.\\n         * Additionally, we must loop in case a new node is added\\n         * while we are doing this. Also, unlike other uses of\\n         * unparkSuccessor, we need to know if CAS to reset status\\n         * fails, if so rechecking.\\n         */</span>\\n        <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            Node h <span class=\\\"token operator\\\">=</span> head<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>h <span class=\\\"token operator\\\">!=</span> null <span class=\\\"token operator\\\">&amp;&amp;</span> h <span class=\\\"token operator\\\">!=</span> tail<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">int</span> ws <span class=\\\"token operator\\\">=</span> h<span class=\\\"token punctuation\\\">.</span>waitStatus<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>ws <span class=\\\"token operator\\\">==</span> Node<span class=\\\"token punctuation\\\">.</span>SIGNAL<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token operator\\\">!</span><span class=\\\"token function\\\">compareAndSetWaitStatus</span><span class=\\\"token punctuation\\\">(</span>h<span class=\\\"token punctuation\\\">,</span> Node<span class=\\\"token punctuation\\\">.</span>SIGNAL<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                        <span class=\\\"token keyword\\\">continue</span><span class=\\\"token punctuation\\\">;</span>            <span class=\\\"token comment\\\">// loop to recheck cases</span>\\n                    <span class=\\\"token function\\\">unparkSuccessor</span><span class=\\\"token punctuation\\\">(</span>h<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//遍历queue，通知所有SHARED的节点，因为是共享模式，这些Node都应该被唤醒，直到遇到某个EXCLUSIVE的Node</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n                <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>ws <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span> <span class=\\\"token operator\\\">&amp;&amp;</span>\\n                         <span class=\\\"token operator\\\">!</span><span class=\\\"token function\\\">compareAndSetWaitStatus</span><span class=\\\"token punctuation\\\">(</span>h<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> Node<span class=\\\"token punctuation\\\">.</span>PROPAGATE<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">continue</span><span class=\\\"token punctuation\\\">;</span>                <span class=\\\"token comment\\\">// loop on failed CAS</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>h <span class=\\\"token operator\\\">==</span> head<span class=\\\"token punctuation\\\">)</span>                   <span class=\\\"token comment\\\">// loop if head changed</span>\\n                <span class=\\\"token keyword\\\">break</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>unparkSuccessor跟之前独占模式里面的是同一个函数，即调用unpark唤醒Thread。</p>\\n<p>我们知道为了避免获取不到锁长时间等待，一般阻塞的方法都会支持带超时时间的方法，比如CountDownLatch里就有</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">await</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">long</span> timeout<span class=\\\"token punctuation\\\">,</span> TimeUnit unit<span class=\\\"token punctuation\\\">)</span>\\n        <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> sync<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">tryAcquireSharedNanos</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">,</span> unit<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toNanos</span><span class=\\\"token punctuation\\\">(</span>timeout<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>调用AQS里面的tryAcquireSharedNanos方法</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">tryAcquireSharedNanos</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">long</span> nanosTimeout<span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">interrupted</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">InterruptedException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">tryAcquireShared</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">>=</span> <span class=\\\"token number\\\">0</span> <span class=\\\"token operator\\\">||</span>\\n            <span class=\\\"token function\\\">doAcquireSharedNanos</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">,</span> nanosTimeout<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">doAcquireSharedNanos</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">long</span> nanosTimeout<span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>nanosTimeout <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">0</span>L<span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">long</span> deadline <span class=\\\"token operator\\\">=</span> System<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">nanoTime</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> nanosTimeout<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">final</span> Node node <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">addWaiter</span><span class=\\\"token punctuation\\\">(</span>Node<span class=\\\"token punctuation\\\">.</span>SHARED<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">boolean</span> failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">final</span> Node p <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">predecessor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>p <span class=\\\"token operator\\\">==</span> head<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                    <span class=\\\"token keyword\\\">int</span> r <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">tryAcquireShared</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>r <span class=\\\"token operator\\\">>=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                        <span class=\\\"token function\\\">setHeadAndPropagate</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">,</span> r<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                        p<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> null<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// help GC</span>\\n                        failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n                        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token punctuation\\\">}</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n                nanosTimeout <span class=\\\"token operator\\\">=</span> deadline <span class=\\\"token operator\\\">-</span> System<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">nanoTime</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>nanosTimeout <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">0</span>L<span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//如果已经没时间了，直接return false</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">shouldParkAfterFailedAcquire</span><span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">,</span> node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&amp;&amp;</span>\\n                    nanosTimeout <span class=\\\"token operator\\\">></span> spinForTimeoutThreshold<span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//大于某个阈值，才park，否则进入自旋</span>\\n                    LockSupport<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">parkNanos</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">,</span> nanosTimeout<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//调用带超时的park方法</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">interrupted</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">InterruptedException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">finally</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>failed<span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token function\\\">cancelAcquire</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>可以看到，跟不带超时的doAcquireSharedInterruptibly方法相比，区别主要在于每次for循环期间，检查时间是否过期和调用带超时的park。nanosTimeout > spinForTimeoutThreshold这个判断主要是因为park/unpark本身也需要花时间，为了更准确地完成超时的机制，在超时时间马上就要到了的时候，就进入自旋，不再park了，这应该是Doug Lea测试了park/unpark时间比1000纳秒要长吧。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token comment\\\">/**\\n     * The number of nanoseconds for which it is faster to spin\\n     * rather than to use timed park. A rough estimate suffices\\n     * to improve responsiveness with very short timeouts.\\n     */</span>\\n    <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">long</span> spinForTimeoutThreshold <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">1000</span>L<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<h1 id=\\\"总结\\\"><a href=\\\"#%E6%80%BB%E7%BB%93\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>总结</h1>\\n<p>J.U.C里AQS是一个相当核心的类，可以说没有它就没有J.U.C包。推荐大家看看<a href=\\\"http://gee.cs.oswego.edu/dl/papers/aqs.pdf\\\">AQS</a>这篇论文（网上有一些翻译，推荐大家还是看原文吧）。主要是用一个state表示状态，子类可以根据需要来定义state的含义，以及获取释放资源时具体如何操作state，当然需要通过CAS实现原子更改。当获取不到state的时候，线程加入队列，挂起。释放之后，唤醒队列中的线程。AQS支持两种模式，独占EXCLUSIVE和共享SHARED。J.U.C里本身也有很多直接继承AQS实现的类，包括Lock，CountDownLatch，Semaphore，FutureTask等，如果这些还不能满足你的使用，那么可以直接继承AQS来实现需要。</p>\\n<h1 id=\\\"refers\\\"><a href=\\\"#refers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Refers</h1>\\n<ol>\\n<li><a href=\\\"http://gee.cs.oswego.edu/dl/papers/aqs.pdf\\\">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li>\\n<li><a href=\\\"http://ifeve.com/introduce-abstractqueuedsynchronizer/\\\">http://ifeve.com/introduce-abstractqueuedsynchronizer/</a></li>\\n<li><a href=\\\"http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/\\\">http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/</a></li>\\n<li><a href=\\\"http://ifeve.com/jdk1-8-abstractqueuedsynchronizer-part2/\\\">http://ifeve.com/jdk1-8-abstractqueuedsynchronizer-part2/</a></li>\\n<li><a href=\\\"http://book.douban.com/subject/6522893/\\\">http://book.douban.com/subject/6522893/</a></li>\\n<li><a href=\\\"http://my.oschina.net/magicly007/blog/364102\\\">http://my.oschina.net/magicly007/blog/364102</a></li>\\n</ol>\\n<blockquote>\\n<p>Written with <a href=\\\"https://stackedit.io/\\\">StackEdit</a>.</p>\\n</blockquote>\",\"timeToRead\":9,\"excerpt\":\"java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了 atomic包里Integer/Long对应的原子类，主要基于CAS； 一些同步子，包括Lock，CountDownLatch，Semaphore…\",\"fields\":{\"slug\":\"/java-concurrrency-3-juc-source-code-read/\"},\"frontmatter\":{\"title\":\"Java Concurrency（三）——J.U.C AQS源码解读\",\"date\":\"2015-01-13\",\"category\":\"Java\",\"tags\":[\"Java\",\"concurrency\",\"jdk\",\"源码阅读\"]}}},{\"node\":{\"html\":\"<p>java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了</p>\\n<ol>\\n<li>atomic包里Integer/Long对应的原子类，主要基于CAS；</li>\\n<li>一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；</li>\\n<li>关于线程执行的Executors类等；</li>\\n<li>一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。</li>\\n</ol>\\n<p>今天我们主要介绍atomic包下相关内容。</p>\\n<!-- more -->\\n<h1 id=\\\"cas\\\"><a href=\\\"#cas\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>CAS</h1>\\n<p>atomic包下的类主要基于现代主流 CPU 都支持的一种指令，Compare and Swap（CAS），这个指令能为多线程编程带来更好的性能。引用《Java Concurrency in Practice》里的一段描述：</p>\\n<blockquote>\\n<p>在这里，CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。简单介绍一下这个指令的操作过程：首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU 会将旧的数值返回。这一系列的操作是原子的。它们虽然看似复杂，但却是 Java 5 并发机制优于原有锁机制的根本。简单来说，CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”。</p>\\n</blockquote>\\n<h1 id=\\\"atomicinteger\\\"><a href=\\\"#atomicinteger\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>AtomicInteger</h1>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">volatile</span> <span class=\\\"token keyword\\\">int</span> value<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>AtomicInteger里面只包含一个字段，用来记录当前值，定义为volatile是为了满足<strong>可见性</strong>。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">  <span class=\\\"token comment\\\">// setup to use Unsafe.compareAndSwapInt for updates</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> Unsafe unsafe <span class=\\\"token operator\\\">=</span> Unsafe<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getUnsafe</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">long</span> valueOffset<span class=\\\"token punctuation\\\">;</span>\\n\\n    <span class=\\\"token keyword\\\">static</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n        valueOffset <span class=\\\"token operator\\\">=</span> unsafe<span class=\\\"token punctuation\\\">.</span>objectFieldOffset\\n            <span class=\\\"token punctuation\\\">(</span>AtomicInteger<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">class</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getDeclaredField</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"value\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n      <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token class-name\\\">Exception</span> ex<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Error</span><span class=\\\"token punctuation\\\">(</span>ex<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>一开始定义了static变量Unsafe，AtomicInteger里面的方法都是对unsafe里面</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">native</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">compareAndSwapInt</span><span class=\\\"token punctuation\\\">(</span>Object var1<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">long</span> var2<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> var4<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> var5<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>方法的封装。\\n我们来看原子性的i++，</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">int</span> <span class=\\\"token function\\\">getAndIncrement</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">int</span> current <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">get</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">int</span> next <span class=\\\"token operator\\\">=</span> current <span class=\\\"token operator\\\">+</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSet</span><span class=\\\"token punctuation\\\">(</span>current<span class=\\\"token punctuation\\\">,</span> next<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token keyword\\\">return</span> current<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>在一个无限循环里面，首先获取当前值，用当前值+1，然后调用</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">   <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">compareAndSet</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> expect<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> update<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n\\t<span class=\\\"token keyword\\\">return</span> unsafe<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">compareAndSwapInt</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">,</span> valueOffset<span class=\\\"token punctuation\\\">,</span> expect<span class=\\\"token punctuation\\\">,</span> update<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>unsafe.compareAndSwapInt(this, valueOffset, expect, update)的含义是把this对象里面valueOffset（在一开始static代码里面获取）这个位置（即value值）跟expect比较，如果相等，则修改为update，返回true；如果不相等，说明在获取到current之后有其他线程修改过value的值，则重新来一遍，一直到修改成功为止。这里就可以看出，理论上来说，这个方法是有可能永远不能返回的，实际而言，当并发冲突很严重，反复compareAndSet(current, next)失败，有可能也需要花费很多时间。</p>\\n<p>AtomicInteger里面的其他方法，基本类似；其他类包括AtomicLong，AtomicReference等也是基本对Unsafe里面compareAndSet的一个封装。</p>\\n<h1 id=\\\"unsafe\\\"><a href=\\\"#unsafe\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Unsafe</h1>\\n<p>前面可以看到Unsafe类在实现atomic的重要性。为什么有Unsafe这个class呢，基本原因是Java不允许代码直接操作内存，好处是更安全，一般不会出现内存泄露，因为有JVM的GC；坏处是有些底层调用执行不了。我的理解是，Unsafe就是这个java安全围城通向比如c++这个不安全外围的一道门，所以叫Unsafe嘛。Unsafe里面基本都是native，即通过JNI调用c/c++等代码。大部分是直接内存操作，以及后面会讲到的挂起唤醒线程等，包括park和unpark。</p>\\n<p>前面到</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">native</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">compareAndSwapInt</span><span class=\\\"token punctuation\\\">(</span>Object var1<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">long</span> var2<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> var4<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> var5<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>这个方法就不是java代码了，如果想看实现的话，需要下载OpenJDK源码，里面是c++代码调用汇编代码，blabla。我不建议大家再往下继续了，原因有几个，一是我们用java等高级语言的目的就是为了避免纠结复杂的底层细节，站在更高层的角度思考问题，而且java里面还有更多的问题等待你去解决，更多的知识可以学习呢！如果你说你已经把java完全掌握了，包括把jdk源码，tomcat、spring，xxxxx源码都看过了，实在没得看了，那我会说，多陪陪家人吧~除非你是JVM开发工程师，哦，那不好意思，大神，当我啥都没说。。。。为了完整性，我贴几个参考链接<a href=\\\"http://www.blogjava.net/mstar/archive/2013/04/24/398351.html\\\">http://www.blogjava.net/mstar/archive/2013/04/24/398351.html</a>, <a href=\\\"http://zl198751.iteye.com/blog/1848575\\\">http://zl198751.iteye.com/blog/1848575</a>.</p>\\n<p>那么如果获取Unsafe呢？Unsafe有一个static方法可以获取Unsafe实例，如下</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"> <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">static</span> Unsafe <span class=\\\"token function\\\">getUnsafe</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        Class <span class=\\\"token class-name\\\">var0</span> <span class=\\\"token operator\\\">=</span> Reflection<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getCallerClass</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>var0<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getClassLoader</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">!=</span> null<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">SecurityException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Unsafe\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">return</span> theUnsafe<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>可是你如果在自己代码里使用，可以编译通过，但是运行时候报错。因为里面限制了调用getUnsafe()这个方法的类必须是启动类加载器Bootstrap Loader。所以如果想在自己代码里面调用Unsafe的话（强烈建议不要这样子做），可以用Java的反射来实现：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">UnsafeSupport</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> Unsafe unsafe<span class=\\\"token punctuation\\\">;</span>\\n\\n        <span class=\\\"token keyword\\\">static</span> <span class=\\\"token punctuation\\\">{</span>\\n            Field field<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token comment\\\">// 由反编译Unsafe类获得的信息</span>\\n                field <span class=\\\"token operator\\\">=</span> Unsafe<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">class</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getDeclaredField</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"theUnsafe\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                field<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">setAccessible</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token comment\\\">// 获取静态属性,Unsafe在启动JVM时随rt.jar装载</span>\\n                unsafe <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>Unsafe<span class=\\\"token punctuation\\\">)</span> field<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">get</span><span class=\\\"token punctuation\\\">(</span>null<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token class-name\\\">Exception</span> e<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                e<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">printStackTrace</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n\\n        <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">static</span> Unsafe <span class=\\\"token function\\\">getInstance</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n<span class=\\\"token comment\\\">//            return Unsafe.getUnsafe();//没有用，只能native获取，否则会抛异常</span>\\n            <span class=\\\"token keyword\\\">return</span> unsafe<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>    </code></pre>\\n      </div>\\n<p>获取到了Unsafe的实例之后，你照样可以自己实现Atomic类，再说一遍，强烈建议不要这样做！！！</p>\\n<h1 id=\\\"cas优点\\\"><a href=\\\"#cas%E4%BC%98%E7%82%B9\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>CAS优点</h1>\\n<p>Compare and Set 是一个非阻塞的算法，这是它的优势。因为使用的是CPU支持的指令，提供了比原有的并发机制更好的性能和伸缩性。可以认为一般情况下性能更好，并且也更容易使用（这才是关键啊）。</p>\\n<h1 id=\\\"cas缺点\\\"><a href=\\\"#cas%E7%BC%BA%E7%82%B9\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>CAS缺点</h1>\\n<h2 id=\\\"aba问题\\\"><a href=\\\"#aba%E9%97%AE%E9%A2%98\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>ABA问题</h2>\\n<p>CAS操作容易导致ABA问题,也就是在做a++之间，a可能被多个线程修改过了，只不过回到了最初的值，这时CAS会认为a的值没有变。a在外面逛了一圈回来，你能保证它没有做任何坏事，不能！！也许它讨闲，把b的值减了一下，把c的值加了一下等等。解决ABA问题的方法有很多，可以考虑增加一个修改计数（版本号），只有修改计数不变的且a值不变的情况下才做a++，atomic包下有AtomicStampedReference类做这个事情，这和事务原子性处理有点类似！</p>\\n<h2 id=\\\"循环时间长开销大\\\"><a href=\\\"#%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%A4%A7\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>循环时间长开销大</h2>\\n<ol>\\n<li>即使没有任何争用也会做一些无用功</li>\\n<li>如果冲突比较严重的话，可能导致多次修改失败，for循环时间很长，可能比同步还慢</li>\\n</ol>\\n<p>我在自己的电脑上用100个线程去修改一个共享变量，发现用AtomicInteger就比synchronized慢，但是都很快！所以还是那个建议，不要过早优化，不要纠结到底是1ms还是2ms，除非测试之后发现确实是性能瓶颈，然后再仔细看一下，是不是代码的使用有问题，要相信，能写到JDK里的代码，一般都不会有问题。一般不到一天几千万上亿的PV，应该是没啥问题的。而且JVM对synchronized做了很多优化，包括锁去除（Lock Elimination），轻量级锁，偏向锁等，所以写代码的时候首先还是主要考虑代码正确、清晰、可维护。</p>\\n<h2 id=\\\"只能保证一个共享变量的原子操作\\\"><a href=\\\"#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>只能保证一个共享变量的原子操作</h2>\\n<p>如果并发约束条件涉及到两个变量，就不能用两个原子变量来达到整体的原子性，还是得用同步。当然你也可以用一个变通的方法，定义一个class，里面包含约束条件涉及到的变量，然后用AtomicReference来实现原子性。</p>\\n<h1 id=\\\"总结\\\"><a href=\\\"#%E6%80%BB%E7%BB%93\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>总结</h1>\\n<p>atomic包下的类比如AtomicInteger实现原子性的方法主要是依靠现代主流 CPU 都支持的CAS指令，它是通过Unsafe类的native方法调用的。一般而言性能比用锁同步要好，但是都已经很好了，一般而言不会遇到性能问题，关键还是看它的语义是否满足使用要求，以及是否可以让代码更清新。</p>\\n<h1 id=\\\"refers\\\"><a href=\\\"#refers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Refers</h1>\\n<ol>\\n<li><a href=\\\"http://my.oschina.net/lifany/blog/133513\\\">http://my.oschina.net/lifany/blog/133513</a></li>\\n<li><a href=\\\"http://zl198751.iteye.com/blog/1848575\\\">http://zl198751.iteye.com/blog/1848575</a></li>\\n<li><a href=\\\"http://blog.csdn.net/aesop_wubo/article/details/7537960\\\">http://blog.csdn.net/aesop_wubo/article/details/7537960</a></li>\\n<li><a href=\\\"http://my.oschina.net/u/177808/blog/166819\\\">http://my.oschina.net/u/177808/blog/166819</a></li>\\n<li><a href=\\\"http://www.blogjava.net/mstar/archive/2013/04/24/398351.html\\\">http://www.blogjava.net/mstar/archive/2013/04/24/398351.html</a></li>\\n<li><a href=\\\"http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/\\\">http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/</a></li>\\n<li><a href=\\\"http://zeroturnaround.com/rebellabs/dangerous-code-how-to-be-unsafe-with-java-classes-objects-in-memory/\\\">http://zeroturnaround.com/rebellabs/dangerous-code-how-to-be-unsafe-with-java-classes-objects-in-memory/</a></li>\\n<li><a href=\\\"http://www.pwendell.com/2012/08/13/java-lock-free-deepdive.html\\\">http://www.pwendell.com/2012/08/13/java-lock-free-deepdive.html</a></li>\\n</ol>\",\"timeToRead\":4,\"excerpt\":\"java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了 atomic包里Integer/Long对应的原子类，主要基于CAS； 一些同步子，包括Lock，CountDownLatch，Semaphore…\",\"fields\":{\"slug\":\"/juc-source-code-read-atomic/\"},\"frontmatter\":{\"title\":\"J.U.C源码解读之atomic\",\"date\":\"2015-01-13\",\"category\":\"Java\",\"tags\":[\"Java\",\"concurrency\",\"jdk\",\"源码阅读\"]}}}]}},\"pathContext\":{\"current\":6,\"skip\":50,\"total\":6}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---page-6-30d46f4b591a09091403.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Magicly's Blog\"}},\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"html\":\"<p>经常遇到一个问题，需要在内存里缓存一批数据来提高效率（避免每次都读取DB）。那问题来了，这些对象到底会占用多大内存呢，这直接决定了可以缓存多少条记录，以及上线之后是否会内存不够等问题。</p>\\n<p>来看几种解决方法。</p>\\n<!-- more -->\\n<h1 id=\\\"测试\\\"><a href=\\\"#%E6%B5%8B%E8%AF%95\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>测试</h1>\\n<p>实践是检验真理的唯一标准！比如你要想cache10w条记录，那你就把10w条记录加载到内存，然后看看到底用了多少内存。至于怎么看内存花了多少，你可以</p>\\n<ol>\\n<li>任务管理器</li>\\n<li>top</li>\\n<li>Java Runtime类</li>\\n<li>blabla。。。。</li>\\n</ol>\\n<p>我们来看看直接从Java程序里能获取到的Runtime。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">import</span> java<span class=\\\"token punctuation\\\">.</span>util<span class=\\\"token punctuation\\\">.</span>*<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">/**\\n * Created by magicalli on 2015/2/3.\\n */</span>\\n<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">TestMemory</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">A</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">int</span> a<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">main</span><span class=\\\"token punctuation\\\">(</span>String<span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span> args<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"--- Memory Usage ---:\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        Runtime rt <span class=\\\"token operator\\\">=</span> Runtime<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getRuntime</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token comment\\\">//打印总内存大小 //打印空闲内存大小 //打印已用内存大小 单位(字节)</span>\\n        <span class=\\\"token keyword\\\">long</span> usedMemory <span class=\\\"token operator\\\">=</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">totalMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">-</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">freeMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Total Memory= \\\"</span> <span class=\\\"token operator\\\">+</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">totalMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\" Free Memory = \\\"</span> <span class=\\\"token operator\\\">+</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">freeMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\" Used　Memory=\\\"</span> <span class=\\\"token operator\\\">+</span> usedMemory<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n        <span class=\\\"token comment\\\">// 把你要测试的占用内存的代码放在这里------start--------------</span>\\n        <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">int</span> N <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">100000</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">int</span><span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span> arr <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">int</span><span class=\\\"token punctuation\\\">[</span>N<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n        Integer<span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span> arr2 <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Integer</span><span class=\\\"token punctuation\\\">[</span>N<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n        A<span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span> arrA <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">A</span><span class=\\\"token punctuation\\\">[</span>N<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> i <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> i <span class=\\\"token operator\\\">&lt;</span> N<span class=\\\"token punctuation\\\">;</span> i<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            arr<span class=\\\"token punctuation\\\">[</span>i<span class=\\\"token punctuation\\\">]</span> <span class=\\\"token operator\\\">=</span> i<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">//            arr2[i] = i;</span>\\n<span class=\\\"token comment\\\">//            arrA[i] = new A();</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token comment\\\">//        List&lt;Integer> list = new ArrayList&lt;Integer>();</span>\\n        Map<span class=\\\"token generics function\\\"><span class=\\\"token punctuation\\\">&lt;</span>Integer<span class=\\\"token punctuation\\\">,</span> String<span class=\\\"token punctuation\\\">></span></span> map <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">HashMap</span><span class=\\\"token generics function\\\"><span class=\\\"token punctuation\\\">&lt;</span>Integer<span class=\\\"token punctuation\\\">,</span> String<span class=\\\"token punctuation\\\">></span></span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">//        for (int i = 0; i &lt; N; i++) {</span>\\n<span class=\\\"token comment\\\">//            list.add(i);</span>\\n<span class=\\\"token comment\\\">//            map.put(i, UUID.randomUUID().toString());</span>\\n<span class=\\\"token comment\\\">//        }</span>\\n<span class=\\\"token comment\\\">//        System.out.println(map.size());</span>\\n        <span class=\\\"token comment\\\">// 把你要测试的占用内存的代码放在这里------end--------------</span>\\n\\n        <span class=\\\"token keyword\\\">long</span> usedMemory2 <span class=\\\"token operator\\\">=</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">totalMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">-</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">freeMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Total Memory= \\\"</span> <span class=\\\"token operator\\\">+</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">totalMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\" Free Memory = \\\"</span> <span class=\\\"token operator\\\">+</span> rt<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">freeMemory</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\" Used　Memory=\\\"</span> <span class=\\\"token operator\\\">+</span> usedMemory2<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">long</span> objMemory <span class=\\\"token operator\\\">=</span> usedMemory2 <span class=\\\"token operator\\\">-</span> usedMemory<span class=\\\"token punctuation\\\">;</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"object use memory: \\\"</span> <span class=\\\"token operator\\\">+</span> objMemory <span class=\\\"token operator\\\">/</span> <span class=\\\"token number\\\">1024</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\"k\\\"</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">\\\" each is: \\\"</span> <span class=\\\"token operator\\\">+</span> objMemory <span class=\\\"token operator\\\">/</span> N<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>上面方法的最大好处就是可以直接获得实际占用内存大小，是比较简单有效的方法。不好的地方就是如果数据量比较小，可能偏差比较大，而且你也不能解释为什么Integer[]比int[]占用内存大很多，关键是专家说：这种内存占用应该是心里算出来的，你还要去run一下程序，明显就low了，还想晋级？再练练吧！所以我们来看看怎么掐指一算！</p>\\n<h1 id=\\\"计算\\\"><a href=\\\"#%E8%AE%A1%E7%AE%97\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>计算</h1>\\n<p>这个需要了解JVM里的内存分布，知道每个对象都有object header，blabal。这里推荐一篇好文<a href=\\\"http://www.cnblogs.com/magialmoon/p/3757767.html\\\">一个Java对象到底占用多大内存？</a>，我就不重复了。</p>\\n<p>还看到另一种计算方式，用的Unsafe，不过感觉没有前面用Instrumentation的好。参考这里<a href=\\\"http://blog.csdn.net/bobpauline/article/details/20699233\\\">Java计算一个对象占用内存的大小</a></p>\\n<h1 id=\\\"线上查看\\\"><a href=\\\"#%E7%BA%BF%E4%B8%8A%E6%9F%A5%E7%9C%8B\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>线上查看</h1>\\n<p>如果是要查看线上程序哪个对象占用了大量内存（比如分析内存泄露），那么可以使用jmap。</p>\\n<h1 id=\\\"相关知识\\\"><a href=\\\"#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>相关知识</h1>\\n<p>你可能需要了解jps，jinfo，打包jar，manifest，查看jvm运行参数等。</p>\\n<h1 id=\\\"refers\\\"><a href=\\\"#refers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Refers</h1>\\n<ol>\\n<li><a href=\\\"http://www.importnew.com/14948.html\\\">http://www.importnew.com/14948.html</a></li>\\n<li><a href=\\\"http://www.cnblogs.com/magialmoon/p/3757767.html\\\">http://www.cnblogs.com/magialmoon/p/3757767.html</a></li>\\n<li><a href=\\\"http://www.oschina.net/question/1_4486\\\">http://www.oschina.net/question/1_4486</a></li>\\n<li><a href=\\\"http://blog.csdn.net/bobpauline/article/details/20699233\\\">http://blog.csdn.net/bobpauline/article/details/20699233</a></li>\\n<li><a href=\\\"http://happyqing.iteye.com/blog/2013639\\\">http://happyqing.iteye.com/blog/2013639</a></li>\\n<li><a href=\\\"http://sunqi.iteye.com/blog/1917802\\\">http://sunqi.iteye.com/blog/1917802</a></li>\\n<li><a href=\\\"http://www.blogjava.net/stone2083/archive/2013/06/08/400410.html\\\">http://www.blogjava.net/stone2083/archive/2013/06/08/400410.html</a></li>\\n<li><a href=\\\"http://yueyemaitian.iteye.com/blog/2033046\\\">http://yueyemaitian.iteye.com/blog/2033046</a></li>\\n<li><a href=\\\"http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html\\\">http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html</a></li>\\n<li><a href=\\\"http://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/\\\">http://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/</a></li>\\n</ol>\\n<blockquote>\\n<p>Written with <a href=\\\"https://stackedit.io/\\\">StackEdit</a>.</p>\\n</blockquote>\",\"timeToRead\":2,\"excerpt\":\"经常遇到一个问题，需要在内存里缓存一批数据来提高效率（避免每次都读取DB）。那问题来了，这些对象到底会占用多大内存呢，这直接决定了可以缓存多少条记录，以及上线之后是否会内存不够等问题。 来看几种解决方法。 测试 实践是检验真理的唯一标准！比如你要想cache10w…\",\"fields\":{\"slug\":\"/how-big-is-a-java-object/\"},\"frontmatter\":{\"title\":\"一个Java对象到底有多大\",\"date\":\"2015-06-13\",\"category\":\"Java\",\"tags\":[\"Java\",\"JVM\",\"Java反射\"]}}},{\"node\":{\"html\":\"<p>java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了</p>\\n<ol>\\n<li>atomic包里Integer/Long对应的原子类，主要基于CAS；</li>\\n<li>一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；</li>\\n<li>关于线程执行的Executors类等；</li>\\n<li>一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。</li>\\n</ol>\\n<p>今天我们主要介绍AbstractQueuedSynchronizer这个可以说是最核心的类，没有之一。整个concurrent包里，基本都直接或间接地用到了这个类。Doug Lea的这篇<a href=\\\"http://gee.cs.oswego.edu/dl/papers/aqs.pdf\\\">论文</a>里面讲AQS的实现。</p>\\n<!-- more -->\\n<h1 id=\\\"aqs\\\"><a href=\\\"#aqs\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>AQS</h1>\\n<p>首先，我们来想象一下，一间屋里有一个大家都想要得到的会让你很爽的东西（something which makes you so happy, e.g. W.C）。当有人进去把门关起来在独占享用的时候，其他人就只能在外面排队等待，既然在等待，你就不能老是去敲门说哎，好了没有啊。老是这样的话里面的人就很不爽了，而且你可以利用这点等待时间干点别的，比如看看小说视频背背单词或者就干脆椅子上睡觉，当前面独占的人爽完之后，就会出来说，啊，好爽，到你们了。然后大家可能按照排队顺序获取或者大家疯抢这个状态，有可能一个人自己进去独占，有可能几个人说，哎没关系，我们可以一起来。然后他们进去爽，爽完之后再出来通知下一个。</p>\\n<p>我们来把上面这段话翻译成AQS里面的术语。有一个状态state，会有多个Thread尝试获取，当一个Thread独占（EXCLUSIVE，比如Lock）之后，其他后面到来的Thread就会被放到一个Queue的队尾（tail），然后睡眠（park），一直等到前面的Thread唤醒（unpark）它，当然这里有可能被假唤醒（就好比你定了闹钟8点起床，结果7点就自然醒或者被外面车吵醒），所以这个Thread会判断一下是不是到自己了，没有的话就继续park（在一个死循环里）；当拥有state的Thread释放（release）之后，它会唤醒Queue中的下一个Thread（unparkSuccessor）。然后下一个Thread获取（acquire）到state，完成自己的任务，然后继续unparkSuccessor。前面主要说的是EXCLUSIVE模式，AQS还支持共享（SHARED）模式，区别在于尝试获取（tryAcquireShared）的时候即使之前已经有Thread获取了state，但是可能仍然能获取（比如ReadLock）。同样释放（doReleaseShared）的时候除了通知Queue里面第一个（head），还会继续通知后续的节点（Node），只要它们是SHARED。</p>\\n<p>AQS就是实现了：</p>\\n<ol>\\n<li>自动管理这个同步状态state（int类型），更新的时候需要用CAS保证原子性</li>\\n<li>阻塞和唤醒线程park/unpark</li>\\n<li>队列管理，一个双向链表实现queue</li>\\n</ol>\\n<p>AQS是一个abstract class，可以通过继承AQS，定义state的含义，以及tryAcquire，tryRelease，以及对应的share模式下tryAcquireShared，tryReleaseShared这几个方法，定义出自己想要的同步子（Synchronizers）。一般而言，是定义一个内部类Sync extends AQS，实现前面说的几个方法，然后再包一层，暴露出相应的方法。这样做的好处是你可以在包装器类里面取更直观的名字，如ReentrantLock里的lock，unlock和CountDownLatch里的countDown，await，而不是太通用的acquire和release等。而且AQS里面一些方法是为了监控和调试使用，直接暴露出来也不好。</p>\\n<p>下面我们来看J.U.C里面两个常用的Synchronizers。</p>\\n<h1 id=\\\"reentrantlock\\\"><a href=\\\"#reentrantlock\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>ReentrantLock</h1>\\n<h2 id=\\\"使用\\\"><a href=\\\"#%E4%BD%BF%E7%94%A8\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>使用</h2>\\n<p>ReentrantLock的语义跟synchronized关键字基本一样，而且我之前看<a href=\\\"http://book.douban.com/subject/6522893/\\\">《深入理解Java虚拟机》</a>里面的评测说JDK6之后，两者的效率基本一致了（JDK5之前ReentrantLock要比synchronized快很多）。Javadoc里面说基本用法如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">X</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">final</span> ReentrantLock lock <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">ReentrantLock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token comment\\\">// ...</span>\\n  <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">m</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    lock<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>  <span class=\\\"token comment\\\">// block until condition holds</span>\\n    <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token comment\\\">// ... method body</span>\\n    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">finally</span> <span class=\\\"token punctuation\\\">{</span>\\n      lock<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">unlock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<h2 id=\\\"源码\\\"><a href=\\\"#%E6%BA%90%E7%A0%81\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>源码</h2>\\n<p>ReentrantLock用state表示是否被锁，0表示没有线程获取到锁，>=1表示某个线程获取了N次锁（因为是重入的，只要保证lock和unlock成对出现就没有问题）。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token comment\\\">/** Synchronizer providing all implementation mechanics */</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">final</span> Sync sync<span class=\\\"token punctuation\\\">;</span>\\n\\n    <span class=\\\"token keyword\\\">abstract</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Sync</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">AbstractQueuedSynchronizer</span> <span class=\\\"token punctuation\\\">{</span></code></pre>\\n      </div>\\n<p>定义了一个内部类，基本任务都代理给sync完成。而Sync又是一个abstract class，这里主要是因为实现了两种抢占锁的机制，公平锁和非公平锁。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">FairSync</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">Sync</span>\\n\\t\\n\\t<span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">NonfairSync</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">Sync</span></code></pre>\\n      </div>\\n<p>所谓公平不公平简单来说就是本文开头说的，当资源释放的时候，大家是按照排队顺序先到先得，还是有人插队大家疯抢。</p>\\n<p>提供了两个构造函数：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token function\\\">ReentrantLock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        sync <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">NonfairSync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//默认非公平锁，AQS论文说非公平锁效率高些，理由其实很简单，公平锁通知队列第一个节点，要把它唤醒，而唤醒是需要时间的，在锁释放到第一个节点被唤醒这段时间其实锁是可以用但是没有被用的（available but not used）；而非公平锁，释放了之后立马就可以被别人用，所以提高了效率，但是有可能导致饥饿锁，这个就要具体看业务需求了。</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token function\\\">ReentrantLock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">boolean</span> fair<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        sync <span class=\\\"token operator\\\">=</span> fair <span class=\\\"token operator\\\">?</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">FairSync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">:</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">NonfairSync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//指定公平与否</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>加锁的实现</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        sync<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>简单代理给了sync，在FairSync里为</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n\\t\\t<span class=\\\"token function\\\">acquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\t<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>acquire的实现在AQS里面：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">acquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token operator\\\">!</span><span class=\\\"token function\\\">tryAcquire</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&amp;&amp;</span>\\n            <span class=\\\"token function\\\">acquireQueued</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">addWaiter</span><span class=\\\"token punctuation\\\">(</span>Node<span class=\\\"token punctuation\\\">.</span>EXCLUSIVE<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span> arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token function\\\">selfInterrupt</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>tryAcquire是要在子类里自己实现的，在FairSync如下;</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t\\t <span class=\\\"token keyword\\\">protected</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">tryAcquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> acquires<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">final</span> Thread current <span class=\\\"token operator\\\">=</span> Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">int</span> c <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>c <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//0表示锁没有被线程用，1表示已经有线程占用</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token operator\\\">!</span><span class=\\\"token function\\\">hasQueuedPredecessors</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&amp;&amp;</span> <span class=\\\"token comment\\\">//判断自己是否是第一个节点，实现公平</span>\\n                    <span class=\\\"token function\\\">compareAndSetState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> acquires<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//CAS更新状态</span>\\n                    <span class=\\\"token function\\\">setExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span>current<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//设置当前线程拥有状态</span>\\n                    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>current <span class=\\\"token operator\\\">==</span> <span class=\\\"token function\\\">getExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//1表示已经有线程占用，再判断一下是否被当前线程占用，来实现重入（Reentrant）特性</span>\\n                <span class=\\\"token keyword\\\">int</span> nextc <span class=\\\"token operator\\\">=</span> c <span class=\\\"token operator\\\">+</span> acquires<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>nextc <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Error</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Maximum lock count exceeded\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>nextc<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//更新状态</span>\\n                <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>如果获取失败，addWaiter(Node.EXCLUSIVE)将当前线程加入队尾</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">private</span> Node <span class=\\\"token function\\\">addWaiter</span><span class=\\\"token punctuation\\\">(</span>Node mode<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        Node node <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Node</span><span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">,</span> mode<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//用当前线程构造Node，独占模式</span>\\n        <span class=\\\"token comment\\\">// Try the fast path of enq; backup to full enq on failure</span>\\n        Node pred <span class=\\\"token operator\\\">=</span> tail<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>pred <span class=\\\"token operator\\\">!=</span> null<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            node<span class=\\\"token punctuation\\\">.</span>prev <span class=\\\"token operator\\\">=</span> pred<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetTail</span><span class=\\\"token punctuation\\\">(</span>pred<span class=\\\"token punctuation\\\">,</span> node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//快速判断，CAS更新tail节点</span>\\n                pred<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">return</span> node<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token function\\\">enq</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//如果失败，进入enq方法</span>\\n        <span class=\\\"token keyword\\\">return</span> node<span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n    \\n\\t <span class=\\\"token keyword\\\">private</span> Node <span class=\\\"token function\\\">enq</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">final</span> Node node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            Node t <span class=\\\"token operator\\\">=</span> tail<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>t <span class=\\\"token operator\\\">==</span> null<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token comment\\\">// Must initialize</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetHead</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Node</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//如果还没有head，CAS初始化一个head</span>\\n                    tail <span class=\\\"token operator\\\">=</span> head<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//这段代码跟addWaiter里一样，CAS更新tail节点</span>\\n                node<span class=\\\"token punctuation\\\">.</span>prev <span class=\\\"token operator\\\">=</span> t<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetTail</span><span class=\\\"token punctuation\\\">(</span>t<span class=\\\"token punctuation\\\">,</span> node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                    t<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token keyword\\\">return</span> t<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>现在我们已经将获取不到锁的线程加入队尾了，现在要将它挂起acquireQueued(addWaiter(Node.EXCLUSIVE), arg))：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">acquireQueued</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">final</span> Node node<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">boolean</span> failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">boolean</span> interrupted <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//在一个死循环中，避免假唤醒</span>\\n                <span class=\\\"token keyword\\\">final</span> Node p <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">predecessor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//获取当前节点的前一个节点，如果是head说明自己是第一个可以获取资源的线程，实现公平</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>p <span class=\\\"token operator\\\">==</span> head <span class=\\\"token operator\\\">&amp;&amp;</span> <span class=\\\"token function\\\">tryAcquire</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//是第一个可以获取资源的线程并且尝试获取成功</span>\\n                    <span class=\\\"token function\\\">setHead</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                    p<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> null<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// help GC</span>\\n                    failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token keyword\\\">return</span> interrupted<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">shouldParkAfterFailedAcquire</span><span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">,</span> node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&amp;&amp;</span>\\n                    <span class=\\\"token function\\\">parkAndCheckInterrupt</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//没有获取到资源，睡眠park去</span>\\n                    interrupted <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">finally</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>failed<span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token function\\\">cancelAcquire</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">parkAndCheckInterrupt</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        LockSupport<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">park</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">return</span> Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">interrupted</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>上面完成了获取锁的过程，简单来说就是尝试获取，失败就加入队尾，挂起，等待被唤醒。</p>\\n<p>下面来看看释放锁</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">unlock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        sync<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">release</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//代理给sync，调用AQS的release</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token comment\\\">//下面代码在AQS中</span>\\n\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">release</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">tryRelease</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//尝试释放资源，需要在子类里实现</span>\\n            Node h <span class=\\\"token operator\\\">=</span> head<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>h <span class=\\\"token operator\\\">!=</span> null <span class=\\\"token operator\\\">&amp;&amp;</span> h<span class=\\\"token punctuation\\\">.</span>waitStatus <span class=\\\"token operator\\\">!=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token function\\\">unparkSuccessor</span><span class=\\\"token punctuation\\\">(</span>h<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//通知下一个节点</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">unparkSuccessor</span><span class=\\\"token punctuation\\\">(</span>Node node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token comment\\\">/*\\n         * If status is negative (i.e., possibly needing signal) try\\n         * to clear in anticipation of signalling.  It is OK if this\\n         * fails or if status is changed by waiting thread.\\n         */</span>\\n        <span class=\\\"token keyword\\\">int</span> ws <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span>waitStatus<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>ws <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token function\\\">compareAndSetWaitStatus</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">,</span> ws<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n        <span class=\\\"token comment\\\">/*\\n         * Thread to unpark is held in successor, which is normally\\n         * just the next node.  But if cancelled or apparently null,\\n         * traverse backwards from tail to find the actual\\n         * non-cancelled successor.\\n         */</span>\\n         <span class=\\\"token comment\\\">// 主要在这里找到下一个需要通知的节点，如果node.next就是需要通知的节点，则直接通知；否则，可能node.next == null（原因是双向链表设置b.pre = a和a.next = b的时候不能保证原子性，只能保证b.pre = a成功，这时候另一条线程可能看到a.next == null）或者s.waitStatus > 0（原因是线程等不及被取消了static final int CANCELLED = 1;），这个时候就要从队尾tail开始找，找到离队头head最近的一个需要通知的节点Node。</span>\\n        Node s <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span>next<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>s <span class=\\\"token operator\\\">==</span> null <span class=\\\"token operator\\\">||</span> s<span class=\\\"token punctuation\\\">.</span>waitStatus <span class=\\\"token operator\\\">></span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            s <span class=\\\"token operator\\\">=</span> null<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span>Node t <span class=\\\"token operator\\\">=</span> tail<span class=\\\"token punctuation\\\">;</span> t <span class=\\\"token operator\\\">!=</span> null <span class=\\\"token operator\\\">&amp;&amp;</span> t <span class=\\\"token operator\\\">!=</span> node<span class=\\\"token punctuation\\\">;</span> t <span class=\\\"token operator\\\">=</span> t<span class=\\\"token punctuation\\\">.</span>prev<span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>t<span class=\\\"token punctuation\\\">.</span>waitStatus <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n                    s <span class=\\\"token operator\\\">=</span> t<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>s <span class=\\\"token operator\\\">!=</span> null<span class=\\\"token punctuation\\\">)</span>\\n            LockSupport<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">unpark</span><span class=\\\"token punctuation\\\">(</span>s<span class=\\\"token punctuation\\\">.</span>thread<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//唤醒线程</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>看看需要在子类里实现的tryRelease：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t\\t<span class=\\\"token keyword\\\">protected</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">tryRelease</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> releases<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">int</span> c <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">-</span> releases<span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//释放锁，state减去相应的值</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">!=</span> <span class=\\\"token function\\\">getExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">IllegalMonitorStateException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//避免A线程锁了之后，B线程故意捣乱释放锁</span>\\n            <span class=\\\"token keyword\\\">boolean</span> free <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>c <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//当前线程已经完全释放了锁</span>\\n                free <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token function\\\">setExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span>null<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//释放锁的拥有者</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>c<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//设置状态，这个方面没有同步，没有CAS，有同学问过岂不是有线程并发问题？其实到这里，只有一个线程会调用这个方法，所以不会有并发错误，仔细想想，是吧？是吧？</span>\\n            <span class=\\\"token keyword\\\">return</span> free<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>到这里，基本都已经完成，对了，还没有说非公平锁NonfairSync是怎么抢占锁的。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t\\t<span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">lock</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//先抢一把（插队），万一成功了就不排队，不公平性就体现在这里！</span>\\n                <span class=\\\"token function\\\">setExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">else</span>\\n                <span class=\\\"token function\\\">acquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>跟FairSync.lock()对比，可以看出，只是在acquire(1)之前，先抢一把，抢不到才乖乖的去排队。</p>\\n<p>我们再看看NonfairSync.tryAcquire()怎么实现的</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t\\t<span class=\\\"token keyword\\\">protected</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">tryAcquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> acquires<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">nonfairTryAcquire</span><span class=\\\"token punctuation\\\">(</span>acquires<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//调用父类方法nonfairTryAcquire</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t\\t<span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">nonfairTryAcquire</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> acquires<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">final</span> Thread current <span class=\\\"token operator\\\">=</span> Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">int</span> c <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>c <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> acquires<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//跟FairSync.tryAcquire只有这里一行有差异，即少了!hasQueuedPredecessors()，也就是说不判断前面有没有人，任何时候只要它醒来，都会去抢，所以不公平！============刚又看了一遍，发现其实final boolean acquireQueued(final Node node, int arg)方法里已经有node.predecessor() == head的判断，感觉这个不公平的tryAcquire貌似没有意义，各位看官怎么看呢，请留言哈，谢谢~</span>\\n                    <span class=\\\"token function\\\">setExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span>current<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>current <span class=\\\"token operator\\\">==</span> <span class=\\\"token function\\\">getExclusiveOwnerThread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">int</span> nextc <span class=\\\"token operator\\\">=</span> c <span class=\\\"token operator\\\">+</span> acquires<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>nextc <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token comment\\\">// overflow</span>\\n                    <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Error</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Maximum lock count exceeded\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token function\\\">setState</span><span class=\\\"token punctuation\\\">(</span>nextc<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<h1 id=\\\"countdownlatch\\\"><a href=\\\"#countdownlatch\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>CountDownLatch</h1>\\n<p>我们之前说了，AQS支持独占EXCLUSIVE和共享SHARED两种模式，而刚刚的ReentrantLock的就是独占模式，我们来看看一个使用共享模式的类。</p>\\n<h2 id=\\\"使用-1\\\"><a href=\\\"#%E4%BD%BF%E7%94%A8-1\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>使用</h2>\\n<p>CountDownLatch就好比一道门，它可以用来等所有资源都到齐了，才开门，让这些线程同时通过。比如如下是CountDownLatch一个通用用法：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">package</span> concurrentStudy<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token keyword\\\">import</span> java<span class=\\\"token punctuation\\\">.</span>util<span class=\\\"token punctuation\\\">.</span>concurrent<span class=\\\"token punctuation\\\">.</span>CountDownLatch<span class=\\\"token punctuation\\\">;</span>\\n\\n<span class=\\\"token comment\\\">/**\\n * Created by magicalli on 2014/12/13.\\n */</span>\\n<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">IndexPlusPlusTest01</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">int</span> NThreads <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">// 线程数</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">int</span> M <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">100000</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//循环次数，太小的话（比如10）可能看不出来效果</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">volatile</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">int</span> n <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//加volatile的目的是为了证明volatile没有“原子性”！</span>\\n\\n    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">main</span><span class=\\\"token punctuation\\\">(</span>String<span class=\\\"token punctuation\\\">[</span><span class=\\\"token punctuation\\\">]</span> args<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">final</span> CountDownLatch startGate <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">CountDownLatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">final</span> CountDownLatch endGate <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">CountDownLatch</span><span class=\\\"token punctuation\\\">(</span>NThreads<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n\\n        <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> i <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> i <span class=\\\"token operator\\\">&lt;</span> NThreads<span class=\\\"token punctuation\\\">;</span> i<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Thread</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Runnable</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token annotation punctuation\\\">@Override</span>\\n                <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">run</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                    <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n                        startGate<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">await</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//所有线程start之后等待“门“打开，保证同时真正开始运行</span>\\n                    <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token class-name\\\">InterruptedException</span> e<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                        e<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">printStackTrace</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token punctuation\\\">}</span>\\n\\n                    <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> j <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> j <span class=\\\"token operator\\\">&lt;</span> M<span class=\\\"token punctuation\\\">;</span> j<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                        n <span class=\\\"token operator\\\">+=</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token punctuation\\\">}</span>\\n\\n                    endGate<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">countDown</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">start</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n\\n        startGate<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">countDown</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//打开“门”，让所有线程同时run起来</span>\\n        <span class=\\\"token keyword\\\">long</span> t1 <span class=\\\"token operator\\\">=</span> System<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentTimeMillis</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        endGate<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">await</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//等所有线程都结束之后才打印n，否则总是会打出错误的n；我见过这里用Thread.sleep()，但是问题在于，你怎么知道该等多久才能保证所有线程结束以及刚好结束呢？！</span>\\n        <span class=\\\"token keyword\\\">long</span> t2 <span class=\\\"token operator\\\">=</span> System<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">currentTimeMillis</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"cost time: \\\"</span> <span class=\\\"token operator\\\">+</span> <span class=\\\"token punctuation\\\">(</span>t2 <span class=\\\"token operator\\\">-</span> t1<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        System<span class=\\\"token punctuation\\\">.</span>out<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">println</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"n: \\\"</span> <span class=\\\"token operator\\\">+</span> n<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>对了，上面代码是拿来验证volatile不具备原子性的，是错误的代码哦。如果想并发安全，大家可以想想可以用哪些方式实现。</p>\\n<h2 id=\\\"源码-1\\\"><a href=\\\"#%E6%BA%90%E7%A0%81-1\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>源码</h2>\\n<p>CountDownLatch同样也是定义了一个继承自AQS的内部类Sync：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">Sync</span> <span class=\\\"token keyword\\\">extends</span> <span class=\\\"token class-name\\\">AbstractQueuedSynchronizer</span></code></pre>\\n      </div>\\n<p>构造函数如下：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token function\\\">CountDownLatch</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> count<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>count <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">IllegalArgumentException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"count &lt; 0\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">.</span>sync <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Sync</span><span class=\\\"token punctuation\\\">(</span>count<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>count表示有多少个任务还在运行，每个Thread完成了任务或者准备好开始之前，就会调用countDown方法将count-1，当count==0时候，await就不再阻塞，所有在上面阻塞的Thread都可以顺利通过。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">await</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        sync<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">acquireSharedInterruptibly</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>直接调用AQS的acquireSharedInterruptibly方法，从方法名可以看出，支持中断响应</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">acquireSharedInterruptibly</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">interrupted</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">InterruptedException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//响应中断</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">tryAcquireShared</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token function\\\">doAcquireSharedInterruptibly</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>tryAcquireShared在子类中实现：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">        <span class=\\\"token keyword\\\">protected</span> <span class=\\\"token keyword\\\">int</span> <span class=\\\"token function\\\">tryAcquireShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> acquires<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">?</span> <span class=\\\"token number\\\">1</span> <span class=\\\"token operator\\\">:</span> <span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//如果state为0，说明所有Thread完成任务，可以不阻塞了</span>\\n        <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>如果没有获取到，将Thread加入队尾，挂起。下面这个方法跟独占模式下acquireQueued(addWaiter(Node.EXCLUSIVE), arg))这个方法代码是基本一致的。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">doAcquireSharedInterruptibly</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span>\\n        <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">final</span> Node node <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">addWaiter</span><span class=\\\"token punctuation\\\">(</span>Node<span class=\\\"token punctuation\\\">.</span>SHARED<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//共享模式</span>\\n        <span class=\\\"token keyword\\\">boolean</span> failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">final</span> Node p <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">predecessor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>p <span class=\\\"token operator\\\">==</span> head<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                    <span class=\\\"token keyword\\\">int</span> r <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">tryAcquireShared</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>r <span class=\\\"token operator\\\">>=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                        <span class=\\\"token function\\\">setHeadAndPropagate</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">,</span> r<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//跟EXCLUSIVE的一大区别</span>\\n                        p<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> null<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// help GC</span>\\n                        failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n                        <span class=\\\"token keyword\\\">return</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token punctuation\\\">}</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">shouldParkAfterFailedAcquire</span><span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">,</span> node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&amp;&amp;</span>\\n                    <span class=\\\"token function\\\">parkAndCheckInterrupt</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">InterruptedException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//响应中断，这里直接抛异常</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">finally</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>failed<span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token function\\\">cancelAcquire</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">setHeadAndPropagate</span><span class=\\\"token punctuation\\\">(</span>Node node<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> propagate<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        Node h <span class=\\\"token operator\\\">=</span> head<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// Record old head for check below</span>\\n        <span class=\\\"token function\\\">setHead</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token comment\\\">/*\\n         * Try to signal next queued node if:\\n         *   Propagation was indicated by caller,\\n         *     or was recorded (as h.waitStatus either before\\n         *     or after setHead) by a previous operation\\n         *     (note: this uses sign-check of waitStatus because\\n         *      PROPAGATE status may transition to SIGNAL.)\\n         * and\\n         *   The next node is waiting in shared mode,\\n         *     or we don't know, because it appears null\\n         *\\n         * The conservatism in both of these checks may cause\\n         * unnecessary wake-ups, but only when there are multiple\\n         * racing acquires/releases, so most need signals now or soon\\n         * anyway.\\n         */</span>\\n         <span class=\\\"token comment\\\">// 如果当前节点是愿意共享，并且下一个节点也是愿意共享的，那么就进入doReleaseShared，唤醒下一个节点，下面会详解</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>propagate <span class=\\\"token operator\\\">></span> <span class=\\\"token number\\\">0</span> <span class=\\\"token operator\\\">||</span> h <span class=\\\"token operator\\\">==</span> null <span class=\\\"token operator\\\">||</span> h<span class=\\\"token punctuation\\\">.</span>waitStatus <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span> <span class=\\\"token operator\\\">||</span>\\n            <span class=\\\"token punctuation\\\">(</span>h <span class=\\\"token operator\\\">=</span> head<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">==</span> null <span class=\\\"token operator\\\">||</span> h<span class=\\\"token punctuation\\\">.</span>waitStatus <span class=\\\"token operator\\\">&lt;</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            Node s <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span>next<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>s <span class=\\\"token operator\\\">==</span> null <span class=\\\"token operator\\\">||</span> s<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">isShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token function\\\">doReleaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>前面完成了等待CountDownLatch的count变成0的过程，下面看看countDown</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">countDown</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        sync<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">releaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//调用AQS的</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token comment\\\">// AQS中</span>\\n\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">releaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">tryReleaseShared</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span><span class=\\\"token comment\\\">//尝试释放，需要在子类中实现</span>\\n            <span class=\\\"token function\\\">doReleaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//真正释放</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t\\t<span class=\\\"token comment\\\">// Sync子类中实现</span>\\n\\t    <span class=\\\"token keyword\\\">protected</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">tryReleaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> releases<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token comment\\\">// Decrement count; signal when transition to zero</span>\\n            <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">int</span> c <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">getState</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>c <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">int</span> nextc <span class=\\\"token operator\\\">=</span> c<span class=\\\"token operator\\\">-</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSetState</span><span class=\\\"token punctuation\\\">(</span>c<span class=\\\"token punctuation\\\">,</span> nextc<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">// 在死循环中CAS将count-1</span>\\n                    <span class=\\\"token keyword\\\">return</span> nextc <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n        \\n    <span class=\\\"token comment\\\">// AQS中</span>\\n\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">doReleaseShared</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token comment\\\">/*\\n         * Ensure that a release propagates, even if there are other\\n         * in-progress acquires/releases.  This proceeds in the usual\\n         * way of trying to unparkSuccessor of head if it needs\\n         * signal. But if it does not, status is set to PROPAGATE to\\n         * ensure that upon release, propagation continues.\\n         * Additionally, we must loop in case a new node is added\\n         * while we are doing this. Also, unlike other uses of\\n         * unparkSuccessor, we need to know if CAS to reset status\\n         * fails, if so rechecking.\\n         */</span>\\n        <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            Node h <span class=\\\"token operator\\\">=</span> head<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>h <span class=\\\"token operator\\\">!=</span> null <span class=\\\"token operator\\\">&amp;&amp;</span> h <span class=\\\"token operator\\\">!=</span> tail<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">int</span> ws <span class=\\\"token operator\\\">=</span> h<span class=\\\"token punctuation\\\">.</span>waitStatus<span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>ws <span class=\\\"token operator\\\">==</span> Node<span class=\\\"token punctuation\\\">.</span>SIGNAL<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token operator\\\">!</span><span class=\\\"token function\\\">compareAndSetWaitStatus</span><span class=\\\"token punctuation\\\">(</span>h<span class=\\\"token punctuation\\\">,</span> Node<span class=\\\"token punctuation\\\">.</span>SIGNAL<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                        <span class=\\\"token keyword\\\">continue</span><span class=\\\"token punctuation\\\">;</span>            <span class=\\\"token comment\\\">// loop to recheck cases</span>\\n                    <span class=\\\"token function\\\">unparkSuccessor</span><span class=\\\"token punctuation\\\">(</span>h<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//遍历queue，通知所有SHARED的节点，因为是共享模式，这些Node都应该被唤醒，直到遇到某个EXCLUSIVE的Node</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n                <span class=\\\"token keyword\\\">else</span> <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>ws <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">0</span> <span class=\\\"token operator\\\">&amp;&amp;</span>\\n                         <span class=\\\"token operator\\\">!</span><span class=\\\"token function\\\">compareAndSetWaitStatus</span><span class=\\\"token punctuation\\\">(</span>h<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> Node<span class=\\\"token punctuation\\\">.</span>PROPAGATE<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">continue</span><span class=\\\"token punctuation\\\">;</span>                <span class=\\\"token comment\\\">// loop on failed CAS</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>h <span class=\\\"token operator\\\">==</span> head<span class=\\\"token punctuation\\\">)</span>                   <span class=\\\"token comment\\\">// loop if head changed</span>\\n                <span class=\\\"token keyword\\\">break</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>unparkSuccessor跟之前独占模式里面的是同一个函数，即调用unpark唤醒Thread。</p>\\n<p>我们知道为了避免获取不到锁长时间等待，一般阻塞的方法都会支持带超时时间的方法，比如CountDownLatch里就有</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">await</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">long</span> timeout<span class=\\\"token punctuation\\\">,</span> TimeUnit unit<span class=\\\"token punctuation\\\">)</span>\\n        <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">return</span> sync<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">tryAcquireSharedNanos</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">,</span> unit<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">toNanos</span><span class=\\\"token punctuation\\\">(</span>timeout<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>调用AQS里面的tryAcquireSharedNanos方法</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">tryAcquireSharedNanos</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">long</span> nanosTimeout<span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">interrupted</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">InterruptedException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">tryAcquireShared</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">>=</span> <span class=\\\"token number\\\">0</span> <span class=\\\"token operator\\\">||</span>\\n            <span class=\\\"token function\\\">doAcquireSharedNanos</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">,</span> nanosTimeout<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span>\\n\\n\\t<span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">doAcquireSharedNanos</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> arg<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">long</span> nanosTimeout<span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">throws</span> InterruptedException <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>nanosTimeout <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">0</span>L<span class=\\\"token punctuation\\\">)</span>\\n            <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">long</span> deadline <span class=\\\"token operator\\\">=</span> System<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">nanoTime</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">+</span> nanosTimeout<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">final</span> Node node <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">addWaiter</span><span class=\\\"token punctuation\\\">(</span>Node<span class=\\\"token punctuation\\\">.</span>SHARED<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">boolean</span> failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token keyword\\\">final</span> Node p <span class=\\\"token operator\\\">=</span> node<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">predecessor</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>p <span class=\\\"token operator\\\">==</span> head<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                    <span class=\\\"token keyword\\\">int</span> r <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">tryAcquireShared</span><span class=\\\"token punctuation\\\">(</span>arg<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>r <span class=\\\"token operator\\\">>=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                        <span class=\\\"token function\\\">setHeadAndPropagate</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">,</span> r<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                        p<span class=\\\"token punctuation\\\">.</span>next <span class=\\\"token operator\\\">=</span> null<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// help GC</span>\\n                        failed <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span>\\n                        <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n                    <span class=\\\"token punctuation\\\">}</span>\\n                <span class=\\\"token punctuation\\\">}</span>\\n                nanosTimeout <span class=\\\"token operator\\\">=</span> deadline <span class=\\\"token operator\\\">-</span> System<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">nanoTime</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>nanosTimeout <span class=\\\"token operator\\\">&lt;=</span> <span class=\\\"token number\\\">0</span>L<span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">return</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//如果已经没时间了，直接return false</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">shouldParkAfterFailedAcquire</span><span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">,</span> node<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">&amp;&amp;</span>\\n                    nanosTimeout <span class=\\\"token operator\\\">></span> spinForTimeoutThreshold<span class=\\\"token punctuation\\\">)</span><span class=\\\"token comment\\\">//大于某个阈值，才park，否则进入自旋</span>\\n                    LockSupport<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">parkNanos</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">,</span> nanosTimeout<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token comment\\\">//调用带超时的park方法</span>\\n                <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>Thread<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">interrupted</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                    <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">InterruptedException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">finally</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span>failed<span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token function\\\">cancelAcquire</span><span class=\\\"token punctuation\\\">(</span>node<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>可以看到，跟不带超时的doAcquireSharedInterruptibly方法相比，区别主要在于每次for循环期间，检查时间是否过期和调用带超时的park。nanosTimeout > spinForTimeoutThreshold这个判断主要是因为park/unpark本身也需要花时间，为了更准确地完成超时的机制，在超时时间马上就要到了的时候，就进入自旋，不再park了，这应该是Doug Lea测试了park/unpark时间比1000纳秒要长吧。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">\\t<span class=\\\"token comment\\\">/**\\n     * The number of nanoseconds for which it is faster to spin\\n     * rather than to use timed park. A rough estimate suffices\\n     * to improve responsiveness with very short timeouts.\\n     */</span>\\n    <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">long</span> spinForTimeoutThreshold <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">1000</span>L<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<h1 id=\\\"总结\\\"><a href=\\\"#%E6%80%BB%E7%BB%93\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>总结</h1>\\n<p>J.U.C里AQS是一个相当核心的类，可以说没有它就没有J.U.C包。推荐大家看看<a href=\\\"http://gee.cs.oswego.edu/dl/papers/aqs.pdf\\\">AQS</a>这篇论文（网上有一些翻译，推荐大家还是看原文吧）。主要是用一个state表示状态，子类可以根据需要来定义state的含义，以及获取释放资源时具体如何操作state，当然需要通过CAS实现原子更改。当获取不到state的时候，线程加入队列，挂起。释放之后，唤醒队列中的线程。AQS支持两种模式，独占EXCLUSIVE和共享SHARED。J.U.C里本身也有很多直接继承AQS实现的类，包括Lock，CountDownLatch，Semaphore，FutureTask等，如果这些还不能满足你的使用，那么可以直接继承AQS来实现需要。</p>\\n<h1 id=\\\"refers\\\"><a href=\\\"#refers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Refers</h1>\\n<ol>\\n<li><a href=\\\"http://gee.cs.oswego.edu/dl/papers/aqs.pdf\\\">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li>\\n<li><a href=\\\"http://ifeve.com/introduce-abstractqueuedsynchronizer/\\\">http://ifeve.com/introduce-abstractqueuedsynchronizer/</a></li>\\n<li><a href=\\\"http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/\\\">http://ifeve.com/jdk1-8-abstractqueuedsynchronizer/</a></li>\\n<li><a href=\\\"http://ifeve.com/jdk1-8-abstractqueuedsynchronizer-part2/\\\">http://ifeve.com/jdk1-8-abstractqueuedsynchronizer-part2/</a></li>\\n<li><a href=\\\"http://book.douban.com/subject/6522893/\\\">http://book.douban.com/subject/6522893/</a></li>\\n<li><a href=\\\"http://my.oschina.net/magicly007/blog/364102\\\">http://my.oschina.net/magicly007/blog/364102</a></li>\\n</ol>\\n<blockquote>\\n<p>Written with <a href=\\\"https://stackedit.io/\\\">StackEdit</a>.</p>\\n</blockquote>\",\"timeToRead\":9,\"excerpt\":\"java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了 atomic包里Integer/Long对应的原子类，主要基于CAS； 一些同步子，包括Lock，CountDownLatch，Semaphore…\",\"fields\":{\"slug\":\"/java-concurrrency-3-juc-source-code-read/\"},\"frontmatter\":{\"title\":\"Java Concurrency（三）——J.U.C AQS源码解读\",\"date\":\"2015-01-13\",\"category\":\"Java\",\"tags\":[\"Java\",\"concurrency\",\"jdk\",\"源码阅读\"]}}},{\"node\":{\"html\":\"<p>java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了</p>\\n<ol>\\n<li>atomic包里Integer/Long对应的原子类，主要基于CAS；</li>\\n<li>一些同步子，包括Lock，CountDownLatch，Semaphore，FutureTask等，这些都是基于AbstractQueuedSynchronizer类；</li>\\n<li>关于线程执行的Executors类等；</li>\\n<li>一些并发的集合类，比如ConcurrentHashMap，ConcurrentLinkedQueue，CopyOnWriteArrayList等。</li>\\n</ol>\\n<p>今天我们主要介绍atomic包下相关内容。</p>\\n<!-- more -->\\n<h1 id=\\\"cas\\\"><a href=\\\"#cas\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>CAS</h1>\\n<p>atomic包下的类主要基于现代主流 CPU 都支持的一种指令，Compare and Swap（CAS），这个指令能为多线程编程带来更好的性能。引用《Java Concurrency in Practice》里的一段描述：</p>\\n<blockquote>\\n<p>在这里，CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。简单介绍一下这个指令的操作过程：首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU 会将旧的数值返回。这一系列的操作是原子的。它们虽然看似复杂，但却是 Java 5 并发机制优于原有锁机制的根本。简单来说，CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”。</p>\\n</blockquote>\\n<h1 id=\\\"atomicinteger\\\"><a href=\\\"#atomicinteger\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>AtomicInteger</h1>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">volatile</span> <span class=\\\"token keyword\\\">int</span> value<span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>AtomicInteger里面只包含一个字段，用来记录当前值，定义为volatile是为了满足<strong>可见性</strong>。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">  <span class=\\\"token comment\\\">// setup to use Unsafe.compareAndSwapInt for updates</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> Unsafe unsafe <span class=\\\"token operator\\\">=</span> Unsafe<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getUnsafe</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">long</span> valueOffset<span class=\\\"token punctuation\\\">;</span>\\n\\n    <span class=\\\"token keyword\\\">static</span> <span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n        valueOffset <span class=\\\"token operator\\\">=</span> unsafe<span class=\\\"token punctuation\\\">.</span>objectFieldOffset\\n            <span class=\\\"token punctuation\\\">(</span>AtomicInteger<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">class</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getDeclaredField</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"value\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n      <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token class-name\\\">Exception</span> ex<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Error</span><span class=\\\"token punctuation\\\">(</span>ex<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>一开始定义了static变量Unsafe，AtomicInteger里面的方法都是对unsafe里面</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">native</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">compareAndSwapInt</span><span class=\\\"token punctuation\\\">(</span>Object var1<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">long</span> var2<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> var4<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> var5<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>方法的封装。\\n我们来看原子性的i++，</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">int</span> <span class=\\\"token function\\\">getAndIncrement</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">for</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">;</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">int</span> current <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">get</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">int</span> next <span class=\\\"token operator\\\">=</span> current <span class=\\\"token operator\\\">+</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">if</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token function\\\">compareAndSet</span><span class=\\\"token punctuation\\\">(</span>current<span class=\\\"token punctuation\\\">,</span> next<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">)</span>\\n                <span class=\\\"token keyword\\\">return</span> current<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>在一个无限循环里面，首先获取当前值，用当前值+1，然后调用</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">   <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">compareAndSet</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">int</span> expect<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> update<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n\\t<span class=\\\"token keyword\\\">return</span> unsafe<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">compareAndSwapInt</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">this</span><span class=\\\"token punctuation\\\">,</span> valueOffset<span class=\\\"token punctuation\\\">,</span> expect<span class=\\\"token punctuation\\\">,</span> update<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>unsafe.compareAndSwapInt(this, valueOffset, expect, update)的含义是把this对象里面valueOffset（在一开始static代码里面获取）这个位置（即value值）跟expect比较，如果相等，则修改为update，返回true；如果不相等，说明在获取到current之后有其他线程修改过value的值，则重新来一遍，一直到修改成功为止。这里就可以看出，理论上来说，这个方法是有可能永远不能返回的，实际而言，当并发冲突很严重，反复compareAndSet(current, next)失败，有可能也需要花费很多时间。</p>\\n<p>AtomicInteger里面的其他方法，基本类似；其他类包括AtomicLong，AtomicReference等也是基本对Unsafe里面compareAndSet的一个封装。</p>\\n<h1 id=\\\"unsafe\\\"><a href=\\\"#unsafe\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Unsafe</h1>\\n<p>前面可以看到Unsafe类在实现atomic的重要性。为什么有Unsafe这个class呢，基本原因是Java不允许代码直接操作内存，好处是更安全，一般不会出现内存泄露，因为有JVM的GC；坏处是有些底层调用执行不了。我的理解是，Unsafe就是这个java安全围城通向比如c++这个不安全外围的一道门，所以叫Unsafe嘛。Unsafe里面基本都是native，即通过JNI调用c/c++等代码。大部分是直接内存操作，以及后面会讲到的挂起唤醒线程等，包括park和unpark。</p>\\n<p>前面到</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"><span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">final</span> <span class=\\\"token keyword\\\">native</span> <span class=\\\"token keyword\\\">boolean</span> <span class=\\\"token function\\\">compareAndSwapInt</span><span class=\\\"token punctuation\\\">(</span>Object var1<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">long</span> var2<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> var4<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">int</span> var5<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<p>这个方法就不是java代码了，如果想看实现的话，需要下载OpenJDK源码，里面是c++代码调用汇编代码，blabla。我不建议大家再往下继续了，原因有几个，一是我们用java等高级语言的目的就是为了避免纠结复杂的底层细节，站在更高层的角度思考问题，而且java里面还有更多的问题等待你去解决，更多的知识可以学习呢！如果你说你已经把java完全掌握了，包括把jdk源码，tomcat、spring，xxxxx源码都看过了，实在没得看了，那我会说，多陪陪家人吧~除非你是JVM开发工程师，哦，那不好意思，大神，当我啥都没说。。。。为了完整性，我贴几个参考链接<a href=\\\"http://www.blogjava.net/mstar/archive/2013/04/24/398351.html\\\">http://www.blogjava.net/mstar/archive/2013/04/24/398351.html</a>, <a href=\\\"http://zl198751.iteye.com/blog/1848575\\\">http://zl198751.iteye.com/blog/1848575</a>.</p>\\n<p>那么如果获取Unsafe呢？Unsafe有一个static方法可以获取Unsafe实例，如下</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\"> <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">static</span> Unsafe <span class=\\\"token function\\\">getUnsafe</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n        Class <span class=\\\"token class-name\\\">var0</span> <span class=\\\"token operator\\\">=</span> Reflection<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getCallerClass</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">2</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>var0<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getClassLoader</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">!=</span> null<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">SecurityException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Unsafe\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">else</span> <span class=\\\"token punctuation\\\">{</span>\\n            <span class=\\\"token keyword\\\">return</span> theUnsafe<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>可是你如果在自己代码里使用，可以编译通过，但是运行时候报错。因为里面限制了调用getUnsafe()这个方法的类必须是启动类加载器Bootstrap Loader。所以如果想在自己代码里面调用Unsafe的话（强烈建议不要这样子做），可以用Java的反射来实现：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-java\\\"><code class=\\\"language-java\\\">    <span class=\\\"token keyword\\\">static</span> <span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">UnsafeSupport</span> <span class=\\\"token punctuation\\\">{</span>\\n        <span class=\\\"token keyword\\\">private</span> <span class=\\\"token keyword\\\">static</span> Unsafe unsafe<span class=\\\"token punctuation\\\">;</span>\\n\\n        <span class=\\\"token keyword\\\">static</span> <span class=\\\"token punctuation\\\">{</span>\\n            Field field<span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n                <span class=\\\"token comment\\\">// 由反编译Unsafe类获得的信息</span>\\n                field <span class=\\\"token operator\\\">=</span> Unsafe<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">class</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">getDeclaredField</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"theUnsafe\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                field<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">setAccessible</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n                <span class=\\\"token comment\\\">// 获取静态属性,Unsafe在启动JVM时随rt.jar装载</span>\\n                unsafe <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">(</span>Unsafe<span class=\\\"token punctuation\\\">)</span> field<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">get</span><span class=\\\"token punctuation\\\">(</span>null<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token class-name\\\">Exception</span> e<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n                e<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">printStackTrace</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n            <span class=\\\"token punctuation\\\">}</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n\\n        <span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">static</span> Unsafe <span class=\\\"token function\\\">getInstance</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n<span class=\\\"token comment\\\">//            return Unsafe.getUnsafe();//没有用，只能native获取，否则会抛异常</span>\\n            <span class=\\\"token keyword\\\">return</span> unsafe<span class=\\\"token punctuation\\\">;</span>\\n        <span class=\\\"token punctuation\\\">}</span>\\n    <span class=\\\"token punctuation\\\">}</span>    </code></pre>\\n      </div>\\n<p>获取到了Unsafe的实例之后，你照样可以自己实现Atomic类，再说一遍，强烈建议不要这样做！！！</p>\\n<h1 id=\\\"cas优点\\\"><a href=\\\"#cas%E4%BC%98%E7%82%B9\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>CAS优点</h1>\\n<p>Compare and Set 是一个非阻塞的算法，这是它的优势。因为使用的是CPU支持的指令，提供了比原有的并发机制更好的性能和伸缩性。可以认为一般情况下性能更好，并且也更容易使用（这才是关键啊）。</p>\\n<h1 id=\\\"cas缺点\\\"><a href=\\\"#cas%E7%BC%BA%E7%82%B9\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>CAS缺点</h1>\\n<h2 id=\\\"aba问题\\\"><a href=\\\"#aba%E9%97%AE%E9%A2%98\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>ABA问题</h2>\\n<p>CAS操作容易导致ABA问题,也就是在做a++之间，a可能被多个线程修改过了，只不过回到了最初的值，这时CAS会认为a的值没有变。a在外面逛了一圈回来，你能保证它没有做任何坏事，不能！！也许它讨闲，把b的值减了一下，把c的值加了一下等等。解决ABA问题的方法有很多，可以考虑增加一个修改计数（版本号），只有修改计数不变的且a值不变的情况下才做a++，atomic包下有AtomicStampedReference类做这个事情，这和事务原子性处理有点类似！</p>\\n<h2 id=\\\"循环时间长开销大\\\"><a href=\\\"#%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%A4%A7\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>循环时间长开销大</h2>\\n<ol>\\n<li>即使没有任何争用也会做一些无用功</li>\\n<li>如果冲突比较严重的话，可能导致多次修改失败，for循环时间很长，可能比同步还慢</li>\\n</ol>\\n<p>我在自己的电脑上用100个线程去修改一个共享变量，发现用AtomicInteger就比synchronized慢，但是都很快！所以还是那个建议，不要过早优化，不要纠结到底是1ms还是2ms，除非测试之后发现确实是性能瓶颈，然后再仔细看一下，是不是代码的使用有问题，要相信，能写到JDK里的代码，一般都不会有问题。一般不到一天几千万上亿的PV，应该是没啥问题的。而且JVM对synchronized做了很多优化，包括锁去除（Lock Elimination），轻量级锁，偏向锁等，所以写代码的时候首先还是主要考虑代码正确、清晰、可维护。</p>\\n<h2 id=\\\"只能保证一个共享变量的原子操作\\\"><a href=\\\"#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>只能保证一个共享变量的原子操作</h2>\\n<p>如果并发约束条件涉及到两个变量，就不能用两个原子变量来达到整体的原子性，还是得用同步。当然你也可以用一个变通的方法，定义一个class，里面包含约束条件涉及到的变量，然后用AtomicReference来实现原子性。</p>\\n<h1 id=\\\"总结\\\"><a href=\\\"#%E6%80%BB%E7%BB%93\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>总结</h1>\\n<p>atomic包下的类比如AtomicInteger实现原子性的方法主要是依靠现代主流 CPU 都支持的CAS指令，它是通过Unsafe类的native方法调用的。一般而言性能比用锁同步要好，但是都已经很好了，一般而言不会遇到性能问题，关键还是看它的语义是否满足使用要求，以及是否可以让代码更清新。</p>\\n<h1 id=\\\"refers\\\"><a href=\\\"#refers\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Refers</h1>\\n<ol>\\n<li><a href=\\\"http://my.oschina.net/lifany/blog/133513\\\">http://my.oschina.net/lifany/blog/133513</a></li>\\n<li><a href=\\\"http://zl198751.iteye.com/blog/1848575\\\">http://zl198751.iteye.com/blog/1848575</a></li>\\n<li><a href=\\\"http://blog.csdn.net/aesop_wubo/article/details/7537960\\\">http://blog.csdn.net/aesop_wubo/article/details/7537960</a></li>\\n<li><a href=\\\"http://my.oschina.net/u/177808/blog/166819\\\">http://my.oschina.net/u/177808/blog/166819</a></li>\\n<li><a href=\\\"http://www.blogjava.net/mstar/archive/2013/04/24/398351.html\\\">http://www.blogjava.net/mstar/archive/2013/04/24/398351.html</a></li>\\n<li><a href=\\\"http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/\\\">http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/</a></li>\\n<li><a href=\\\"http://zeroturnaround.com/rebellabs/dangerous-code-how-to-be-unsafe-with-java-classes-objects-in-memory/\\\">http://zeroturnaround.com/rebellabs/dangerous-code-how-to-be-unsafe-with-java-classes-objects-in-memory/</a></li>\\n<li><a href=\\\"http://www.pwendell.com/2012/08/13/java-lock-free-deepdive.html\\\">http://www.pwendell.com/2012/08/13/java-lock-free-deepdive.html</a></li>\\n</ol>\",\"timeToRead\":4,\"excerpt\":\"java5之后的java.util.concurrent包是世界级并发大师Doug Lea的作品，里面主要实现了 atomic包里Integer/Long对应的原子类，主要基于CAS； 一些同步子，包括Lock，CountDownLatch，Semaphore…\",\"fields\":{\"slug\":\"/juc-source-code-read-atomic/\"},\"frontmatter\":{\"title\":\"J.U.C源码解读之atomic\",\"date\":\"2015-01-13\",\"category\":\"Java\",\"tags\":[\"Java\",\"concurrency\",\"jdk\",\"源码阅读\"]}}}]}},\"pathContext\":{\"current\":6,\"skip\":50,\"total\":6}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/page-6.json\n// module id = 635\n// module chunks = 195745506856481"],"sourceRoot":""}